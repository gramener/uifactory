<!DOCTYPE html>
<html>
<head>
  <script src="tape.js"></script>
  <script src="../node_modules/lodash/lodash.min.js"></script>
  <script src="../uifactory.js"></script>
</head>
<body>

<!--
## Install from npm

Using [npm](https://www.npmjs.com/get-npm):

```bash
npm install uifactory lodash
```

To include it in your script, use

```html
<script src="node_modules/lodash/lodash.min.js"></script>
<script src="node_modules/uifactory/uifactory.js"></script>
```
-->
  <script>
    tape('Lodash (_) and uifactory are available as globals', function (t) {
      t.ok(_, 'lodash loaded')
      t.ok(uifactory, 'uifactory loaded')
      t.end()
    })
  </script>


<!--
## Components are HTML templates

For example, you can create a `<repeat-html value="8">â˜…</repeat-html>` that component that repeats the star (â˜…) 8 times.

![8 stars](docs/repeat-8-star.png)

Just add a `<template component="repeat-html">` to defines a new `<repeat-html>` element.

**NOTE**: You **MUST** have a dash (hyphen) in the component name (e.g. `repeat-html`).
[It's a standard](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements).

You can use [template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals) inside the `<template>`. For example:

```html
<template component="repeat-html" value="30">
  ${this.innerHTML.repeat(+value)}
</template>
```

When you add the component to your page:

```html
<repeat-html value="8">â˜…</repeat-html>
```

... it renders this output:

![8 stars](docs/repeat-8-star.png)
-->
<template component="repeat-html" value="30">
  ${this.innerHTML.repeat(+value)}
</template>
<repeat-html value="8">â˜…</repeat-html>
<script>
  tape('Components use template literals', function (t) {
    let html = document.querySelector('repeat-html').innerHTML
    t.equals(html.trim(), 'â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…', 'template literals work')
    t.end()
  })
</script>


<!--
## Lodash templates are supported

For better control, you can use [lodash templates](https://lodash.com/docs/#template):

```html
<template component="repeat-template" value="30">
  <% for (var j=0; j < +value; j++) { %>
    <%= this.innerHTML %>
  <% } %>
</template>
```

When you add the component to your page:

```html
<repeat-template value="8">â˜…</repeat-template>
```

... it renders this output:

![8 stars](docs/repeat-8-star.png).

Lodash templates use tags as follows:

- Anything inside `<% ... %>` runs as JavaScript
- Anything inside `<%= ... %>` runs as JavaScript, and the result is "print"ed
-->
<template component="repeat-template" value="30">
  <% for (var j=0; j < +value; j++) { %>
    <%= this.innerHTML %>
  <% } %>
</template>
<repeat-template value="8">â˜…</repeat-template>
<script>
  tape('Components use lodash templates', function (t) {
    let html = document.querySelector('repeat-template').innerHTML
    t.ok(html.trim().match(/^(â˜…\s*){8}$/), 'lodash templates work')
    t.end()
  })
</script>

<!--
## HTML scripts are supported

Some Lodash templates may lead to invalid HTML.

For example, HTML doesn't allow `<% for ... %>` inside a `<tbody>`. (Only `<tr>` is allowed.) So this is invalid:

```html
<template component="table-invalid" rows="3">
  <table>
    <tbody>
      <% for (let i=0; i < +rows; i++) { %>
        <tr><td>Row <%= i %></td></tr>
      <% } %>
    </tbody>
  </table>
</template>
```

Instead, you should wrap your HTML inside a `<script type="text/html">...</script>`.
Anything you write inside it will be rendered as a Lodash template.
(Any HTML outside it is ignored.)

```html
<template component="table-valid" rows="3">
  <script type="text/html">
    <table>
      <tbody>
        <% for (let i=0; i < +rows; i++) { %>
          <tr><td>Row <%= i %></td></tr>
        <% } %>
      </tbody>
    </table>
  </script>
  If you have a script type="text/html",
  any HTML outside it is ignored.
</template>
<table-valid rows="5"></table-valid>
```
-->
<template component="table-valid" rows="3">
  <script type="text/html">
    <table>
      <tbody>
        <% for (let i=0; i < +rows; i++) { %>
          <tr><td>Row <%= i %></td></tr>
        <% } %>
      </tbody>
    </table>
  </script>
  If you have a script type="text/html",
  any HTML outside it is ignored.
</template>
<table-valid rows="5"></table-valid>
<script>
  tape('HTML scripts are supported', function (t) {
    let el = document.querySelector('table-valid')
    t.equals(el.querySelectorAll('table > tbody > tr').length, 5, 'HTML scripts rendered')
    t.ok(!el.innerHTML.match(/ignored/), 'non-script content ignored')
    t.end()
  })
</script>

<!--

## Define properties using template attributes

Any attributes you add to `<template>` creates a property. For example, `<template component="repeat-html" value="30">` defines a property `.value`:

```html
<script>
let el = document.querySelector('repeat-html')  // Find first <repeat-html>
console.log(el.value)                           // Prints the value=".."
el.value = 10                                   // Re-render with value=10
</script>
```

![Access and change properties](docs/g-repeat-properties.gif)

Changing a property via via `.value = ...` *re-renders* the component. So does changing it via `.setAttribute()`.

Notes:

- Attribute names with uppercase letters (e.g. `fontSize`) are converted to lowercase property names (e.g. `fontsize`)
- Attribute names with a dash/hyphen (e.g. `font-size`) are converted to *camelCase* property names (e.g. `fontSize`).
- Attributes not in the template are **NOT** properties, even if you add them in the component (e.g. `<my-component extra="x">` does not define a `.extra`).
-->
<template component="attr-test" mixedCase="mc" font-size="fs"></template>
<attr-test mixedCase="MC" font-size="FS" extra="E"></attr-test>
<script>
  let el = document.querySelector('repeat-html')  // Find first <repeat-html>
  let at = document.querySelector('attr-test')
  tape('Define properties using template attributes', function (t) {
    t.ok(el.value, 'Attributes on template are added as properties')

    el.value = 10
    t.equals(el.innerHTML.trim(), 'â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…',
             'Changing a property via via `.value = ...` *re-renders* the component.')

    el.setAttribute('value', "4")
    t.equals(el.innerHTML.trim(), 'â˜…â˜…â˜…â˜…',
             'So does changing it via `.setAttribute()`.')
    t.end()
  })
  tape('Attribute names with uppercase letters (e.g. `fontSize`) are converted to lowercase property names (e.g. `fontsize`)', function (t) {
    t.equals(at.mixedcase, 'MC', 'mixed-case attrs become lowercase')
    t.end()
  })
  tape('Attribute names with a dash/hyphen (e.g. `font-size`) are converted to *camelCase* property names (e.g. `fontSize`).', function (t) {
    t.equals(at.fontSize, 'FS', 'hyphenated attributes become camelCase')
    t.end()
  })
  tape('Attributes not in the template are **NOT** properties, even if you add them in the component (e.g. `<g-repeat new-attr="x">`).', function (t) {
    t.equals(at.extra, undefined, 'non-template attributes are not properties')
    t.end()
  })
</script>


<!--
## Access properties as variables

Inside templates, properties are available as JavaScript variables.
For example, `<template value="0">` defines the variable `value` with a default of 0:

```html
<template component="repeat-value" value="30">
  <% for (var j=0; j < +value; j++) { %>
    <%= this.innerHTML %>
  <% } %>
</template>
<repeat-value value="8"></repeat-value>
```

Inside the template, the variable `value` has a value `"8"`.
-->
<template component="repeat-value" value="30">
  <% for (var j=0; j < +value; j++) { %>
    <%= this.innerHTML %>
  <% } %>
</template>
<repeat-value value="8">â˜…</repeat-value>
<script>
  tape('Access properties as variables', function (t) {
    let html = document.querySelector('repeat-value').innerHTML
    t.ok(html.trim().match(/^(â˜…\s*){8}$/), 'properties are available as variables')
    t.end()
  })
</script>


<!--
## Access `<template>` as `this`

Inside the [template](#lodash-templates-are-supported),
`this` is the template element (e.g. `<template component="g-repeat">`).
For example

- `this.innerHTML` has the contents of your template.
- `this.querySelectorAll('div')` fetches all `<div>`s in your template

This `<repeat-icons>` component repeats two

```html
<template component="repeat-icons" x="3" y="2">
  <%= this.querySelector('.x').innerHTML.repeat(+x) %>
  <%= this.querySelector('.y').innerHTML.repeat(+y) %>
</template>
```

When you add the component to your page:

```html
<repeat-icons style="padding:3px">
  <span class="x">ðŸ™‚</span>
  <span class="y">ðŸ˜¡</span>
</repeat-icons>
```

... it renders this output:

ðŸ™‚ðŸ™‚ðŸ™‚ðŸ˜¡ðŸ˜¡
-->
<template component="repeat-icons" x="3" y="2">
  <%= this.querySelector('.x').innerHTML.repeat(+x) %>
  <%= this.querySelector('.y').innerHTML.repeat(+y) %>
</template>
<repeat-icons style="padding:3px">
  <span class="x">ðŸ™‚</span>
  <span class="y">ðŸ˜¡</span>
</repeat-icons>
<script>
  tape('Access `<template>` as `this`', function (t) {
    let html = document.querySelector('repeat-icons').innerHTML
    t.ok(html.match(/ðŸ™‚ðŸ™‚ðŸ™‚\s*ðŸ˜¡ðŸ˜¡/), 'this.querySelector is accessible')
    t.end()
  })
</script>

<!--
[Properties](#define-properties-using-template-attributes) are strings by default.
To use numbers, booleans, arrays, etc., you can define properties as JSON.

For example, this creates a simple list component:

```html
<template component="simple-list">
  <script type="application/json">
    // Add a single object {} under <script type="application/json">.
    // Create a list of properties. The property "type" defines how it's treated
    { "properties": [ { "name": "list", "type": "array", "value": [] } ] }
  </script>
  <ul>
    <% list.forEach(function (val) { %>
      <li><%= val %></li>
    <% }) %>
  </ul>
</template>
```

When you add the component to your page, the list attribute is parsed as an array:

```html
<simple-list list="[4, 'ok', true]"></simple-list>
```

... it renders this output:

- 4
- ok
- true

Here's an example that shows all types possible:

```html
<template component="typed-props">
  <script type="application/json">
    // Add a single object {} under <script type="application/json">.
    {
      // It should have a "properties": [list of objects]
      "properties": [
        // Each property has a name, optional type, and value
        { "name": "name", "type": "string", "value": "" },
        { "name": "value", "type": "number", "value": 0 },
        { "name": "is-set", "type": "boolean", "value": false },
        { "name": "data-list", "type": "array", "value": [] },
        { "name": "config", "type": "object", "value": {} },
      ]
    }
  </script>

  Use .name     as string:  <%= name.repeat(3) %>.
  Use .value    as number:  <%= "x".repeat(value) %>.
  Use .isSet    as boolean: <%= typeof isSet %>.
  Use .dataList as array:   <%= dataList.length %>.
  Use .config   as object:  <%= JSON.stringify(config) %>.
</template>
<typed-props name="key" value="10" is-set="true"
  data-list="[1,2,3,4,5,6,7,8]" config="{x:1}"></typed-props>
```

`"properties":` is an array of objects with these keys:

- `name`: property name. e.g. `"name": "data-list"` defines a property `.dataList` and variable `dataList`
- `type`: OPTIONAL: property type. Valid values are `string` (default), `number`, `boolean`, `object` or `array`.
- `value`: default value of the correct type. e.g. `"value": true` for `boolean`, `"value": [30, 40]` for array, etc.

Note:

- The attributes needn't be JSON -- JavaScript is fine. For example, `config="{x:1}"` will work even though `{x:1}` is not valid JSON (`{"x":1}` is JSON).
- The `"properties":` needn't be JSON either. JavaScript is fine. For example, comments are allowed.
-->
<template component="simple-list">
  <script type="application/json">
    // Add a single object {} under <script type="application/json">.
    // Create a list of properties. The property "type" defines how it's treated
    { "properties": [ { "name": "list", "type": "array", "value": [] } ] }
  </script>
  <ul>
    <% list.forEach(function (val) { %>
      <li><%= val %></li>
    <% }) %>
  </ul>
</template>
<simple-list list="[4, 'ok', true]"></simple-list>
<script>
  tape('Define property types in JSON - array', function (t) {
    t.deepEqual(
      Array.from(document.querySelectorAll('simple-list > ul > li')).map(v => v.innerHTML),
      ['4', 'ok', 'true'])
    t.end()
  })
</script>

<template component="typed-props">
  <script type="application/json">
    // Add a single object {} under <script type="application/json">.
    {
      // It should have a "properties": [list of objects]
      "properties": [
        // Each property has a name, optional type, and value
        { "name": "name", "type": "string", "value": "" },
        { "name": "value", "type": "number", "value": 0 },
        { "name": "is-set", "type": "boolean", "value": false },
        { "name": "data-list", "type": "array", "value": [] },
        { "name": "config", "type": "object", "value": {} },
      ]
    }
  </script>

  Use .name as a string: <%= name.repeat(3) %>.
  Use .value as a number: <%= "x".repeat(value) %>.
  Use .isSet as a boolean: <%= typeof isSet %>.
  Use .dataList as array: <%= dataList.length %>.
  Use .config as object: <%= JSON.stringify(config) %>.
</template>
<typed-props name="key" value="10" is-set="true"
  data-list="[1,2,3,4,5,6,7,8]" config="{x:1}"></typed-props>
<script>
  tape('Define property types in JSON - all', function (t) {
    let html = document.querySelector('typed-props').innerHTML
    t.ok(html.match(/string: keykeykey./), 'type: string')
    t.ok(html.match(/number: xxxxxxxxxx./), 'type: number')
    t.ok(html.match(/boolean: boolean./))
    t.ok(html.match(/array: 8./))
    t.ok(html.match(/object: {"x":1}/))
    t.end()
  })
</script>


<!--
## Style components with CSS

Use regular CSS to style the components. The `<template>` is rendered directly inside the component (not a shadow DOM). So you can style the contents directly.

For example, this adds a yellow background to `<g-repeat>` if it has `value="8"`:

```html
<template component="repeat-style" value="30">
  <style>
    repeat-style[value="8"] { background-color: yellow; }
  </style>
  <% for (var j=0; j < +value; j++) { %>
    <%= this.innerHTML %>
  <% } %>
</template>
```

When you add the component to your page:

```html
<repeat-style value="8">â˜…</repeat-style>
```

... it renders this output:

![Yellow background applied to g-repeat](docs/g-repeat-8-star-yellow.png)

UIFactory copies all `<style>`s and `<link rel="stylesheet">`s into the document's HEAD, and runs them only once (even if you use the component multiple times.)

You can style child elements like this:

```css
/* When user hovers on any image inside a g-repeat, add a black border */
repeat-style img:hover {
  border: 1px solid black;
}
```
-->
<template component="repeat-style" value="30">
  <style>
    repeat-style[value="8"] { background-color: yellow; }
  </style>
  <% for (var j=0; j < +value; j++) { %>
    <%= this.innerHTML %>
  <% } %>
</template>
<repeat-style value="8">â˜…</repeat-style>
<script>
  tape('Style components with CSS', function (t) {
    let el = document.querySelector('repeat-style')
    t.equals(getComputedStyle(el).backgroundColor, 'rgb(255, 255, 0)', 'style is applied on component')
    t.end()
  })
</script>


</body>
</html>
