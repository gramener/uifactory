<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <script src="tape.js"></script>
  <script src="../src/uifactory.js"></script>
</head>
<body>
  <h1>UIFactory tests</h1>

  <script>
    /* globals tape */
    // Don't run the tests upfront. Run them after all scripts are loaded. Just cache them for now.
    // Component rendering happens asynchronously
    let __tape = tape
    let __tests = []
    // eslint-disable-next-line no-global-assign
    tape = function (msg, fn) {
      __tests.push([msg, fn])
    }
    const renderEvents = {}
    document.body.addEventListener('render', function (e) {
      const tag = e.target.tagName.toLowerCase()
      const id = e.target.getAttribute('id')
      const key = tag + (id ? '#' + id : '')
      renderEvents[key] = renderEvents[key] || []
      renderEvents[key].push({e: e, html: e.target.innerHTML})
    })
  </script>

<!--

This documentation is synchronised with README.md.
Every section is copied as a comment.
It is followed by a test case that proves every statement in that section.

-->

<!--
## Install from npm

Using [npm](https://www.npmjs.com/get-npm):

```bash
npm install uifactory
```

To include it in your script, use

```html
<script src="node_modules/uifactory/src/uifactory.js"></script>
```
-->
<script>
  tape('uifactory is available as globals', function (t) {
    t.ok(uifactory, 'uifactory loaded')
    t.end()
  })
</script>


<!--
## Components are HTML templates

For example, you can create a component like this:

```html
<repeat-html icon="â˜…" value="8"></repeat-html>
```

... that repeats the star (â˜…) 8 times, like this:

![8 stars](docs/img/repeat-8-star.png)

To create this `<repeat-html>` component, add a `<template $name="repeat-html">` like this:

```html
<template $name="repeat-html" icon="X" value="30">
  ${icon.repeat(+value)}
</template>
```

This uses [template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
inside the `<template>` to generate the HTML. Now,

```html
<repeat-html icon="â˜…" value="8"></repeat-html>
```

... renders this output:

![8 stars](docs/img/repeat-8-star.png)

**NOTE**: You **MUST** have a dash (hyphen) in the component name (e.g. `repeat-html`).
[It's a standard](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements).

-->
<template $name="repeat-html" icon="X" value="30">
  ${icon.repeat(+value)}
</template>
<repeat-html icon="â˜…" value="8"></repeat-html>
<script>
  tape('Components use template literals', function (t) {
    let el = document.querySelector('repeat-html')
    t.equals(el.innerHTML.trim(), 'â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…', 'template literals work')
    t.end()
  })
</script>
<script>
  tape('You **MUST** have a dash (hyphen) in the component name', function (t) {
    try {
      uifactory.register({ name: 'nohyphen', 'template': 'xx' })
      t.end('Component name without hyphens allowed!')
    } catch(e) {
      t.equals(e.name, 'SyntaxError', 'Component name without hyphen disallowed')
    }
    t.end()
  })
</script>

<!--
## Lodash templates are supported

For better control, you can use [Lodash templates](https://lodash.com/docs/#template) like this:

```html
<template $name="repeat-template" value="30" icon="â˜…">
  <% for (var j=0; j < +value; j++) { %>
    <%= icon %>
  <% } %>
</template>
```

When you add the component to your page:

```html
<repeat-template value="8" icon="â˜…"></repeat-template>
```

... it renders this output:

![8 stars](docs/img/repeat-8-star.png).

There are 3 kinds of template tags you can use:

1. **`<% ... %>` evaluates JavaScript**. e.g., `<% console.log('ok') %>` logs `ok`
2. **`<%= ... %>` renders JavaScript**. e.g., ``<%= `<b>${2 + 3}</b>` %>`` renders **5** in bold
3. **`<%- ... %>` renders JavaScript, HTML-escaped**. e.g., ``<%- `<b>${2 + 3}</b>` %>`` renders `<b>5</b>` in bold
-->
<template $name="repeat-template" value="30" icon="â˜…">
  <% for (var j=0; j < +value; j++) { %>
    <%= icon %>
  <% } %>
</template>
<repeat-template value="8" icon="â˜…"></repeat-template>
<script>
  tape('Components use templates', function (t) {
    let el = document.querySelector('repeat-template')
    t.ok(el.innerHTML.trim().match(/^(â˜…\s*){8}$/), 'templates work')
    t.end()
  })
  tape('Templates work as expected', function (t) {
    let tmpl = uifactory.template
    t.equals(tmpl('<% print(x + y) %>')({x: 2, y: 3}), '5', 'template evaluation works')
    t.equals(tmpl('<%= `<b>${x + y}</b>` %>')({x: 2, y: 3}), '<b>5</b>', 'template interpolation works')
    t.equals(tmpl('<%- `<b>${x + y}</b>` %>')({x: 2, y: 3}), '&lt;b&gt;5&lt;/b&gt;', 'template escaping works')
    t.end()
  })
</script>


<!--
## Use `<slot>` in templates

Use [`<slot>` in `<template>`](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots)
to render different parts. For example:

```html
<template $name="repeat-slots" a="1" b="1">
  <% for (var j=0; j < +a; j++) { %>
    <slot name="a">A</slot>
  <% } %>
  <% for (var j=0; j < +a; j++) { %>
    <slot name="b">B</slot>
  <% } %>
  <slot></slot>
</template>
```

When you add the component to your page:

```html
<repeat-slots a="5" b="5">
  <span slot="a">ðŸ”´</span>
  <span slot="b">ðŸŸ©</span>
  <span slot="a"><strong>x</strong></span>
  <span slot="b"><em>y</em></span>
</repeat-slots>
```

... it renders this output:

ðŸ”´**x** ðŸ”´**x** ðŸ”´**x** ðŸ”´**x** ðŸ”´**x** ðŸŸ©*y* ðŸŸ©*y* ðŸŸ©*y* ðŸŸ©*y* ðŸŸ©*y* ðŸ”´ ðŸŸ© **x** *y*

- `<slot name="a">` is replaced with all `slot="a"` elements (ðŸ”´ and **x**).
- `<slot name="b">` is replaced with all `slot="b"` elements (ðŸŸ© and *y*).
- `<slot>` is replaced with all elements in the component (ðŸ”´ ðŸŸ© **x** *y*). This is similar to the `.innerHTML`

See ["Using templates and slots" on MDN](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots)
for more.
-->
<template $name="repeat-slots" a="1" b="1">
  <% for (var j=0; j < +a; j++) { %>
    <slot name="a">A</slot>
  <% } %>
  <% for (var j=0; j < +a; j++) { %>
    <slot name="b">B</slot>
  <% } %>
  <slot></slot>
</template>
<repeat-slots a="5" b="5">
  <span slot="a">ðŸ”´</span>
  <span slot="b">ðŸŸ©</span>
  <span slot="a"><strong>x</strong></span>
  <span slot="b"><em>y</em></span>
</repeat-slots>
<script>
  tape('HTML scripts are supported', function (t) {
    let el = document.querySelector('repeat-slots')
    t.equals(el.innerText.trim(), 'ðŸ”´x ðŸ”´x ðŸ”´x ðŸ”´x ðŸ”´x ðŸŸ©y ðŸŸ©y ðŸŸ©y ðŸŸ©y ðŸŸ©y ðŸ”´ ðŸŸ© x y', 'Slots rendered')
    t.equals(el.querySelectorAll('strong').length, 6, 'Child HTML elements copied')
    t.equals(el.querySelectorAll('em').length, 6, 'Child HTML elements copied')
    t.end()
  })
</script>


<!--
## Wrap tables in `<script type="text/html">`

HTML doesn't allow `<% for ... %>` inside a `<tbody>`. (Only `<tr>` is allowed.) So this is invalid:

```html
<template $name="table-invalid" rows="3">
  <table>
    <tbody>
      <% for (let i=0; i < +rows; i++) { %>
        <tr><td>Row <%= i %></td></tr>
      <% } %>
    </tbody>
  </table>
</template>
```

To avoid this, wrap tables inside a `<script type="text/html">...</script>`.
Anything inside it is rendered as a template. (Any HTML outside it is ignored.)

```html
<template $name="table-valid" rows="0">
  This text is ignored!
  <script type="text/html">
    <table>
      <tbody>
        <% for (let i=0; i < +rows; i++) { %>
          <tr><td>Row <%= i %></td></tr>
        <% } %>
      </tbody>
    </table>
  </script>
  This text is ignored too!
</template>
<table-valid rows="3"></table-valid>
```
-->
<template $name="table-valid" rows="0">
  This text is ignored!
  <script type="text/html">
    <table>
      <tbody>
        <% for (let i=0; i < +rows; i++) { %>
          <tr><td>Row <%= i %></td></tr>
        <% } %>
      </tbody>
    </table>
  </script>
  This text is ignored too!
</template>
<table-valid rows="3"></table-valid>
<script>
  tape('Wrap tables in HTML scripts', function (t) {
    let el = document.querySelector('table-valid')
    // TODO: BRITTLE test. Fails sometimes
    t.equals(el.querySelectorAll('table > tbody > tr').length, 3, 'HTML scripts rendered')
    t.ok(!el.innerHTML.match(/ignored/), 'non-script content ignored')
    t.end()
  })
</script>


<!--
## Create re-usable blocks with `<script type="text/html" $block="...">`

To re-use HTML later, add it into a `<script type="text/html" $block="blockname">...</script>`.

In this example, `$block="wrap"` defines a `wrap()` function that renders the script contents.

```html
<template $name="repeat-block" value="8" icon="â˜…">
  <script type="text/html" $block="wrap">
    <span style="border: 1px solid ${color}"><%- icon.repeat(+value) %></span>
  </script>
  <% if (+value % 2 == 0) { %>
    Even â–¸ <%= wrap({ ...this.$data, color: 'red' }) %>
  <% } else { %>
    <%= wrap({ ...this.$data, color: 'blue' }) %> â—‚ Odd
  <% } %>
</template>
```

When you add two versions of this page:

```html
<repeat-block value="2"></repeat-block>
<repeat-block value="3"></repeat-block>
```

... it renders this output:

![Re-usable blocks rendered](docs/img/repeat-block.png)

Note:

- If multiple `<script type="text/html">` have the same `$block` value, the last one is used
-->

<template $name="repeat-block" value="8" icon="â˜…">
  <!-- $block="wrap" defines a wrap() function that returns this HTML, rendered -->
  <script type="text/html" $block="wrap">
    <span style="border: 1px solid ${color}"><%- icon.repeat(+value) %></span>
  </script>
  <!-- Use wrap() anywhere in the component -->
  <% if (+value % 2 == 0) { %>
    Even â–¸ <%= wrap({ ...this.$data, color: 'red' }) %>
  <% } else { %>
    <%= wrap({ ...this.$data, color: 'blue' }) %> â—‚ Odd
  <% } %>
</template>
<repeat-block value="2"></repeat-block>
<repeat-block value="3"></repeat-block>
<script>
  tape('Create re-usable blocks with `<script type="text/html" $block="...">`', function (t) {
    let els = document.querySelectorAll('repeat-block')
    t.equals(els[0].innerText.trim(), 'Even â–¸ â˜…â˜…', '$block rendered')
    t.equals(els[1].innerText.trim(), 'â˜…â˜…â˜… â—‚ Odd', '$block rendered')
    t.end()
  })
</script>


<!--
## Define properties using `<template attr="...">`

Any attributes you add to `<template>` can be accessed via `element.attr`.
For example, `<template $name="repeat-html" icon="â˜…" value="30">` defines properties
`.icon` and `.value`:

```html
<script>
let el = document.querySelector('repeat-html')  // Find first <repeat-html>
console.log(el.icon)                            // Prints the value of icon=""
console.log(el.value)                           // Prints the value of value=""
el.value = 10                                   // Re-render with value=10
</script>
```

![Access and change properties](docs/img/g-repeat-properties.gif)

Setting a property, e.g. `.value = ...` *re-renders* the component.
So does `.setAttribute('value', ...)`.

Notes:

- Attributes with uppercase letters (e.g. `fontSize`) are converted to lowercase properties (e.g. `fontsize`)
- Attributes with a dash/hyphen (e.g. `font-size`) are converted to *camelCase* properties (e.g. `fontSize`).
- Attributes not in the template are **NOT** properties, even if you add them in the component (e.g. `<my-component extra="x">` does not define a `.extra`).
- But [attributes with types (e.g. `extra:string="x"`) are available as properties](#add-properties-to-an-instance-using-types).
-->
<template $name="attr-test" mixedCase="mc" font-size="fs" query-selector="qs"></template>
<attr-test mixedCase="MC" font-size="FS" extra="E" query-selector="QS"></attr-test>
<script>
  tape('Define properties using template attributes', function (t) {
    let el = document.querySelector('repeat-html')  // Find first <repeat-html>
    t.ok(el.icon, 'Attributes on template are added as properties')
    t.ok(el.value, 'Attributes on template are added as properties')

    el.value = 10
    t.equals(el.innerHTML.trim(), 'â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…', 'Changing a property via via `.value = ...` *re-renders* the component.')

    el.setAttribute('value', "4")
    t.equals(el.innerHTML.trim(), 'â˜…â˜…â˜…â˜…', 'So does changing it via `.setAttribute()`.')
    t.end()
  })
  let at = document.querySelector('attr-test')
  tape('Attribute names with uppercase letters (e.g. `fontSize`) are converted to lowercase property names (e.g. `fontsize`)', function (t) {
    t.equals(at.mixedcase, 'MC', 'mixed-case attrs become lowercase')
    t.end()
  })
  tape('Attribute names with a dash/hyphen (e.g. `font-size`) are converted to *camelCase* property names (e.g. `fontSize`).', function (t) {
    t.equals(at.fontSize, 'FS', 'hyphenated attributes become camelCase')
    t.end()
  })
  tape('Attributes not in the template are **NOT** properties, even if you add them in the component (e.g. `<g-repeat new-attr="x">`).', function (t) {
    t.equals(at.extra, undefined, 'non-template attributes are not properties')
    t.end()
  })
</script>


<!--
## Access properties as variables

Inside templates, properties are available as JavaScript variables.
For example, `<template value:number="30">` defines the variable `value` as a number with a default of 30:

```html
<template $name="repeat-value" value:number="30">
  <% for (var j=0; j < value; j++) { %>
    <slot></slot>
  <% } %>
</template>
<repeat-value value="8"></repeat-value>
```

Inside the template, the variable `value` has a value `"8"`.
-->
<template $name="repeat-value" value:number="30">
  <% for (var j=0; j < value; j++) { %>
    <slot></slot>
  <% } %>
</template>
<repeat-value value="8">â˜…</repeat-value>
<script>
  tape('Access properties as variables', function (t) {
    let el = document.querySelector('repeat-value')
    t.ok(el.innerHTML.trim().match(/^(â˜…\s*){8}$/), 'properties are available as variables')
    t.end()
  })
</script>


<!--
## Define property types using `<template attr:type="...">`

By default, properties are of type `string`. You can specify `number`, `boolean`, `array`,
`object` or `js` like this:

- `<template $name="..." num:number="30">` defines `.num` as a number `30`
- `<template $name="..." bool:boolean="true">` defines `.bool` as a boolean `true`
- `<template $name="..." arr:array="[3,4]">` defines `.arr` as an array `[3, 4]`
- `<template $name="..." obj:object="{x:1}">` defines `.obj` as an object `{x: 1}`
- `<template $name="..." expr:js="Math.ceil(2.2) + num">` defines `.expr` as a JS expression
  evaluating to `3 + num`.
    - You can use global variables like `Math.ceil`
    - You can use other properties like `num`
    - You can use use `data[property]` to access other properties, like `data["num"]` or `data.num`

```html
<template $name="property-types" x="" str:string="" num:number="" bool:boolean=""
  arr:array="" obj:object="" expr:js="" rules:js="">
  <%= JSON.stringify({x, str, num, bool, arr, obj, expr, rules}) %>
</template>
<script>
  var rules = {r: 1}
</script>
<property-types x="x" str="y" num="30" bool="true" arr="[3,4]" obj="{x:1}"
  expr="Math.ceil(2.2) + num + data.num" rules="rules"></property-types>
```

... it renders this output:

```json
{"x":"x","str":"y","num":30,"bool":true,"arr":[3,4],"obj":{"x":1},"expr":63,"rules":{"r":1}}
```
-->

<template $name="property-types" x="" str:string="" num:number="" bool:boolean=""
  arr:array="" obj:object="" expr:js="" rules:js="">
  <%= JSON.stringify({x, str, num, bool, arr, obj, expr, rules}) %>
</template>
<script>
  /* exported rules */
  var rules = {r: 1}
</script>
<property-types x="x" str="y" num="30" bool="true" arr="[3,4]" obj="{x:1}"
  expr="Math.ceil(2.2) + num + data.num" rules="rules"></property-types>
<property-types></property-types>
<script>
  tape('Define property types using `<template attr:js="...">`', function (t) {
    let el = document.querySelectorAll('property-types')
    t.equals(el[0].innerHTML.trim(), '{"x":"x","str":"y","num":30,"bool":true,"arr":[3,4],"obj":{"x":1},"expr":63,"rules":{"r":1}}')
    // NOTE: Currently, the default value is an empty string. In the future, this may change.
    // e.g. we may want num: 0, bool: false, arr: [], obj: {}.
    t.equals(el[1].innerHTML.trim(), '{"x":"","str":"","num":"","bool":"","arr":"","obj":"","expr":"","rules":""}')
    t.end()
  })
</script>


<!--
## Fetch URLs as text using the `:urltext` type

To fetch a URL as text, specify `:urltext` as the property type. For example, this `<fetch-text>`
component displays "Loading..." until a URL is loaded, and then displays its text.

```html
<template $name="fetch-text" src:urltext="">
  <% if (src === null) { %>
    Loading...
  <% } else { %>
    <%= src %>
  <% } %>
</template>
<fetch-text src="page.txt"></fetch-text>
```

... it renders the contents of [page.txt](test/page.txt) as text:

```text
Contents of page.txt
```

This component will be **rendered twice** (and fire two `prerender`/`render` events.)

1. The first happens immediately, before loading the URL. `src` is `null`. This is useful to display a "Loading..." sign
2. The second happens after loading the URL. `src` now has the contents as text

To reload the URL and re-render, you can set `.src = 'page.pxt'` or `.update({src: 'page.txt'})`:

```js
document.querySelector('.fetch-text').src = 'page.txt'
// OR
document.querySelector('.fetch-text').update({ src: 'page.txt' })
```

You can set the property to another URL (which is fetched) or a non-string JS object (which is used as-is).
For example:

```js
document.querySelector('.fetch-text').src = 'page2.txt'   // Loads page2.txt, re-renders
document.querySelector('.fetch-text').src = null          // Sets src=null, re-renders
```
-->
<template $name="fetch-text" src:urltext="">
  <% if (src === null) { %>
    Loading...
  <% } else { %>
    <%= src %>
  <% } %>
</template>
<fetch-text src="page.txt"></fetch-text>
<script>
  tape('Fetch URLs as text using the `:urltext` type', function (t) {
    let el = document.querySelector('fetch-text')
    let refreshed = 0
    function check() {
      let events = renderEvents['fetch-text']
      if (events.length == 2 && refreshed == 0) {
        t.equals(el.innerHTML.trim(), 'Contents of page.txt')
        el.src = 'page.txt'
        refreshed = 1
      } else if (events.length == 4 && refreshed == 1) {
        t.equals(el.innerHTML.trim(), 'Contents of page.txt')
        el.update({ src: 'page.txt' })
        refreshed = 2
      } else if (events.length == 6 && refreshed == 2) {
        t.equals(el.innerHTML.trim(), 'Contents of page.txt')
        el.src = 'page2.txt'
        refreshed = 3
      } else if (events.length == 8 && refreshed == 3) {
        t.equals(el.innerHTML.trim(), 'Contents of page2.txt')
        el.src = null
        refreshed = 4
      } else if (events.length == 9 && refreshed == 4) {
        t.equals(el.innerHTML.trim(), 'Loading...')
        return t.end()
      }
      setTimeout(check, 100)
    }
    check()
  })
</script>


<!--
## Fetch URLs as JSON using the `:urljson` type

To fetch a URL as JSON, specify `:urljson` as the property type. For example, this `<fetch-json>`
component displays "Loading..." until a URL is loaded, and then displays its JSON.

```html
<template $name="fetch-json" src:urljson="">
  <% if (src === null) { %>
    Loading...
  <% } else { %>
    <%= JSON.stringify(src) %>
  <% } %>
</template>
<fetch-url src="page.json"></fetch-url>
```

... it renders the contents of [page.json](test/page.json):

```text
{"text":"abc","number":10,"object":{"x":[1,2,3]}}
```

This component will be **rendered twice** (and fire two `prerender`/`render` events.)

1. The first happens immediately, before loading the URL. `src` is `null`. This is useful to display a "Loading..." sign
2. The second happens after loading the URL. `src` now has the contents as JSON

To reload the URL and re-render, you can set `.src = 'page.json'` or `.update({src: 'page.json'})`:

```js
document.querySelector('.fetch-json').src = 'page.json'
// OR
document.querySelector('.fetch-json').update({ src: 'page.json' })
```

You can set the property to another URL (which is fetched) or a non-string JS object (which is used as-is).
For example:

```js
document.querySelector('.fetch-json').src = 'page2.json'  // Loads page2.json, re-renders
document.querySelector('.fetch-json').src = {x: 1}        // Sets src={x:1}, re-renders
```
-->
<template $name="fetch-json" src:urljson="">
  <% if (src === null) { %>
    Loading...
  <% } else { %>
    <%= JSON.stringify(src) %>
  <% } %>
</template>
<fetch-json src="page.json"></fetch-json>
<script>
  tape('Fetch URLs as json using the `:urljson` type', function (t) {
    let el = document.querySelector('fetch-json')
    let refreshed = 0
    function check() {
      let events = renderEvents['fetch-json']
      if (events.length == 2 && refreshed == 0) {
        t.equals(el.innerHTML.trim(), '{"text":"abc","number":10,"object":{"x":[1,2,3]}}')
        el.src = 'page.json'
        refreshed = 1
      } else if (events.length == 4 && refreshed == 1) {
        t.equals(el.innerHTML.trim(), '{"text":"abc","number":10,"object":{"x":[1,2,3]}}')
        el.update({ src: 'page.json' })
        refreshed = 2
      } else if (events.length == 6 && refreshed == 2) {
        t.equals(el.innerHTML.trim(), '{"text":"abc","number":10,"object":{"x":[1,2,3]}}')
        el.src = 'page2.json'
        refreshed = 3
      } else if (events.length >= 8 && refreshed == 3) {
        t.equals(el.innerHTML.trim(), '{"text":"def","number":20,"object":{"x":[4,5,6]}}')
        el.src = { x: 1 }
        refreshed = 4
      } else if (events.length >= 9 && refreshed == 4) {
        t.equals(el.innerHTML.trim(), '{"x":1}')
        return t.end()
      } else {
        return t.end('Invalid state')
      }
      setTimeout(check, 100)
    }
    check()
  })
</script>


<!--
## Fetch URLs using the `:url` type

To fetch a URL as text, specify `:url` as the property type. For example, this `<fetch-page>`
component displays "Loading..." until a URL is loaded, and then displays it.

```html
<template $name="fetch-page" src:url="">
  <% if (src === null) { %>
    Loading...
  <% } else { %>
    <%= src.text %>
  <% } %>
</template>
<fetch-page src="page.txt"></fetch-page>
```

... it renders the contents of [page.txt](test/page.txt):

```text
Contents of page.txt
```

This component will be **rendered twice** (and fire two `prerender`/`render` events.)

1. The first happens immediately, before loading the URL. `src` is `null`. This is useful to display a "Loading..." sign
2. The second happens after loading the URL. `src` now has the contents as
   a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) object with these keys:
   - `.headers`: response [headers](https://developer.mozilla.org/en-US/docs/Web/API/Response/headers)
   - `.status`: HTTP status code
   - `.statusText`: HTTP status message corresponding to the status code (e.g., OK for 200)
   - `.ok`: `true` if the HTTP status is the range 200-299
   - `.url`: The URL of the response -- after any redirections
   - `.text`: Text from the loaded page. This is **not a Promise**, but the actual text
-->
<template $name="fetch-page" src:url="">
  <% if (src === null) { %>
    Loading...
  <% } else { %>
    <%= src.text %>
  <% } %>
</template>
<fetch-page src="page.txt"></fetch-page>
<script>
  tape('Fetch URLs using the `:url` type', function (t) {
    let el = document.querySelector('fetch-page')
    function check() {
      let events = renderEvents['fetch-page']
      if (!events || events.length < 2)
        return setTimeout(check, 100)
      t.ok(el.src.ok)
      t.equals(el.src.status, 200)
      t.ok(el.src.headers.get('Content-Type').match(/text\/plain/))
      t.equals(el.src.text.trim(), 'Contents of page.txt')
      t.equals(el.innerHTML.trim(), 'Contents of page.txt')
      t.end()
    }
    check()
  })
</script>

<!--
## Access component as `this` inside templates

Inside the [template](#lodash-templates-are-supported), `this` refers to the component itself.

For example, this component makes its parent's background yellow.

```html
<template $name="parent-background" color="yellow">
  <% this.parentElement.style.background = color %>
</template>
```

When you add the component to your page:

```html
<div>
  <parent-background></parent-background>
  This has a yellow background
</div>
```

... it renders this output:

![Access `this` element](docs/img/parent-background.png)

This lets you control not just the component, but parents, siblings, and any other elements on a page.
-->
<template $name="parent-background" color="yellow">
  <% this.parentElement.style.background = color %>
</template>
<div id="parent-container">
  <parent-background></parent-background>
  This has a yellow background
</div>
<script>
  tape('Access component as `this`', function (t) {
    t.equals(document.querySelector('#parent-container').style.background, 'yellow', 'this.parentElement works')
    t.end()
  })
</script>


<!--
## Access component contents as `this.$contents`

`this.$contents` is a cloned version of the custom element's original DOM. You can access what the
user specified inside your component and use it in your template.

For example, `<repeat-icons>` repeats everything under `class="x"` x times, and everything under
`class="y"` y times.

```html
<template $name="repeat-icons" x:number="3" y:number="2">
  <%= this.$contents.querySelector('.x').innerHTML.repeat(x) %>
  <%= this.$contents.querySelector('.y').innerHTML.repeat(y) %>
</template>
```

When you add the component to your page:

```html
<repeat-icons x="5" y="4">
  <span class="x">ðŸ™‚</span>
  <span class="y">ðŸ˜¡</span>
</repeat-icons>
```

... it renders this output:

ðŸ™‚ðŸ™‚ðŸ™‚ðŸ™‚ðŸ™‚ðŸ˜¡ðŸ˜¡ðŸ˜¡ðŸ˜¡
-->
<template $name="repeat-icons" x:number="3" y:number="2">
  <%= this.$contents.querySelector('.x').innerHTML.repeat(x) %>
  <%= this.$contents.querySelector('.y').innerHTML.repeat(y) %>
</template>
<repeat-icons x="5" y="4">
  <span class="x">ðŸ™‚</span>
  <span class="y">ðŸ˜¡</span>
</repeat-icons>
<script>
  tape('Access `<template>` as `this`', function (t) {
    let el = document.querySelector('repeat-icons')
    t.ok(el.innerHTML.match(/ðŸ™‚ðŸ™‚ðŸ™‚ðŸ™‚ðŸ™‚\s*ðŸ˜¡ðŸ˜¡ðŸ˜¡ðŸ˜¡/), 'this.$contents.querySelector is accessible')
    t.end()
  })
</script>


<!--
## Update multiple properties with `.update()`

You can change multiple properties together using `.update({'attr-1': val, 'attr-2': val})`. For
example, this component has 2 properties, `char` and `repeat-value`:

```html
<template $name="repeat-props" char="â˜…" repeat-value:number="10">
  ${char.repeat(repeatValue)}
</template>
<repeat-props char="â˜…" repeat-value="10"></repeat-props>
```

When you add this script to your page:

```html
<script>
  document.querySelector('repeat-props').update({
    char: 'âš¡',
    'repeat-value': 8       // Note: use 'repeat-value', not repeatValue
  })
</script>
```

... updates both `char` and `repeat-value` to generate this output:

![update() changes multiple properties](docs/img/repeat-props.png)

`.update()` also updates the attributes and re-renders the component. `.update()` takes a second dict with options:

- `attr: false` does not update the attribute. Default: `true`
- `render: false` does not re-render the component. Default: `true`

For example, this updates the properties without changing the attributes and without re-rendering.

```html
<script>
  document.querySelector('repeat-props').update({
    char: 'âš½',
    'repeat-value': 5
  }, { attr: false, render: false })
</script>
```

To just re-render the component without changing properties, use `.update()`.

```html
<script>
  document.querySelector('repeat-props').update()
</script>
```
-->

<template $name="repeat-props" char="â˜…" repeat-value:number="10">
  ${char.repeat(repeatValue)}
</template>
<repeat-props char="â˜…" repeat-value="10"></repeat-props>
<script>
  tape('Update multiple properties with `.update()`', function (t) {
    let el = document.querySelector('repeat-props')
    el.update({ char: 'âš¡', 'repeat-value': 8 })
    t.equals(el.innerHTML.trim(), 'âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡', '.update() updates both props')
    t.equals(el.getAttribute('char'), 'âš¡', '.update() updates char')
    t.equals(el.getAttribute('repeat-value'), '8', '.update() updates repeat-value')

    el.update({ char: 'âš½', 'repeat-value': 5 }, { attr: false, render: false })
    t.equals(el.innerHTML.trim(), 'âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡', '.update({}, { render: false }) does not render')
    t.equals(el.getAttribute('char'), 'âš¡', '.update({}, { attr: false }) does not set char="" attr')
    t.equals(el.getAttribute('repeat-value'), '8', '.update({}, { attr: false }) does not set repeat-value="" attr')

    el.update()
    t.equals(el.innerHTML.trim(), 'âš½âš½âš½âš½âš½', '.update() re-renders')

    t.end()
  })
</script>

<!--
## Style components with CSS

Use regular CSS in the `<style>` tag to style components. For example:

```html
<template $name="repeat-style" value:number="30">
  <style>
    /* If class="highlight", add a yellow background */
    repeat-style.highlight { background-color: yellow; }
    /* Color all bold items green INSIDE THE COMPONENT */
    b { color: green; }
  </style>
  <% for (var j=0; j < value; j++) { %>
    <slot></slot>
  <% } %>
</template>
```

When you add the component to your page:

```html
<repeat-style class="highlight" value="8">
  <b>â˜…</b>
</repeat-style>
```

... it renders this output:

![Style applied to repeat-style](docs/img/repeat-style.png)

**You can override component style from the outside**. UIFactory just copies the `<style>` into the
document -- no shadow DOM. Adding this `<style>` overrides the component color:

```css
repeat-style b { color: red; }
```

![Red overrides repeat-style's green](docs/img/repeat-style-red.png)

**You can't pollute styles outside the component**. UIFactory adds the component name before every
selector (if it's missing). For example:

- `b { color: green}` becomes `repeat-style b { color:green; }`
- `repeat-style.highlight {...}` stays as-is -- it already has `repeat-style`
- `.highlight b {...}` becomes `repeat-style .highlight b {...}`. If you want `repeat-style.highlight b {...}` instead, explicitly use that

So any `<b>` outside the component does not turn green.

**Note**: This isn't foolproof. It's simply to prevent accidental pollution.
-->
<template $name="repeat-style" value:number="30">
  <style>
    /* If class="highlight", add a yellow background */
    repeat-style.highlight { background-color: yellow; }
    /* Color all bold items green INSIDE THE COMPONENT */
    b { color: green; }
  </style>
  <% for (var j=0; j < value; j++) { %>
    <slot></slot>
  <% } %>
</template>
<repeat-style class="highlight" value="8">
  <b>â˜…</b>
</repeat-style>
<style>
repeat-style.overridden b { color: red; }
</style>
<repeat-style class="highlight overridden" value="8">
  <b>â˜…</b>
</repeat-style>
<b id="outside">Outside</b>

<script>
  tape('Style components with CSS', function (t) {
    let repeatStyle = getComputedStyle(document.querySelector('repeat-style'))
    let innerStyle = getComputedStyle(document.querySelector('repeat-style b'))
    let overridenStyle = getComputedStyle(document.querySelector('repeat-style.overridden b'))
    let outerStyle = getComputedStyle(document.querySelector('b#outside'))
    let headingStyle = getComputedStyle(document.querySelector('body > h1'))
    t.equals(repeatStyle.backgroundColor, 'rgb(255, 255, 0)', 'style is applied on component')
    t.equals(innerStyle.color, 'rgb(0, 128, 0)', 'style is applied inside component')
    t.equals(overridenStyle.color, 'rgb(255, 0, 0)', 'style is overridden from outside')
    t.equals(outerStyle.color, headingStyle.color, 'style is not applied outside component')
    t.end()
  })
</script>

<!--
## Link to external stylesheets

You can link to external stylesheets. For example, this imports Bootstrap 4.6.

```html
<template $name="bootstrap-button" type="primary">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css">
  <button class="btn btn-<%= type %> m-3"><slot></slot></button>
</template>
```

When you add the component to your page:

```html
<bootstrap-button type="success">â˜…</bootstrap-button>
```

... it renders this output:

![Bootstrap button with external style](docs/img/bootstrap-button.png)

All `<style>`s and `<link rel="stylesheet">`s are appended to the document's HEAD. They run only once (even if you use the component multiple times.)
-->
<template $name="bootstrap-button" type="primary">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css">
  <button class="btn btn-<%= type %> m-3"><slot></slot></button>
</template>
<bootstrap-button type="success">â˜…</bootstrap-button>
<script>
  tape('Link to external stylesheets', function (t) {
    let successColor = 'rgb(40, 167, 69)'
    function check() {
      let el = document.querySelector('bootstrap-button > button')
      let bg = el ? getComputedStyle(el).backgroundColor : ''
      if (bg != successColor)
        return setTimeout(check, 200)
      t.equals(bg, successColor, 'external style is applied')
      t.end()
    }
    check()
  })
</script>

<!--
## Override styles normally

UIFactory just copies the HTML into the component. There's no shadow DOM. You can override a component styles normally.

For example, this `<style>` affects buttons inside the component:

```html
<style>
  /* When user hovers on any button inside a repeat-style, color it lime */
  repeat-style.green-hover button:hover {
    background-color: lime;
  }
</style>
<repeat-style class="green-hover" value="5">
  ðŸ™‚<button>â˜…</button>
</repeat-style>
```

... it renders this output:

![repeat-style colors button on hover](docs/img/repeat-style-hover.gif)
-->

<style>
  /* When user hovers on any button inside a repeat-style, or a .lime button, color it lime */
  repeat-style button:hover, repeat-style button.lime {
    background-color: lime;
  }
</style>
<repeat-style class="green-hover" value="5">
  ðŸ™‚<button>â˜…</button>
</repeat-style>
<script>
  tape('Override styles normally', function (t) {
    let el = document.querySelector('repeat-style.green-hover > button')
    el.classList.add('lime')
    t.equals(getComputedStyle(el).backgroundColor, 'rgb(0, 255, 0)', 'style is overridden')
    t.end()
  })
</script>

<!--
## Add behavior with JavaScript

Use regular JavaScript to add logic and interactivity.

```html
<template $name="text-diff" x="" y="">
  "${x}" is ${uifactory.textDiff.distance(x, y)} steps from "${y}"
  <script src="https://cdn.jsdelivr.net/npm/levenshtein@1.0.5/lib/levenshtein.js"></script>
  <script>
    // By convention, we add any JS related to a component under uifactory.<componentName>
    uifactory.textDiff = {
      distance: (x, y) => (new Levenshtein(x, y)).distance
    }
  </script>
</template>
```

When you add the component to your page:

```html
<text-diff x="back" y="book"></text-diff>
```

... it renders this output:

```text
"back" is 2 steps from "book"
```

All `<script>`s are copied from the `<template>` and appended to the document's BODY in order.
They run only once (even if you use the component multiple times.)
-->
<template $name="text-diff" x="" y="">
  "${x}" is ${uifactory.textDiff.distance(x, y)} steps from "${y}"
  <script src="https://cdn.jsdelivr.net/npm/levenshtein@1.0.5/lib/levenshtein.js"></script>
  <script>
    /* globals Levenshtein */
    // By convention, we add any JS related to a component under uifactory.<componentName>
    uifactory.textDiff = {
      distance: (x, y) => (new Levenshtein(x, y)).distance
    }
  </script>
</template>
<text-diff x="back" y="book"></text-diff>
<script>
  tape('Add behavior with JavaScript', function (t) {
    let el = document.querySelector('text-diff')
    el.$ready.then(() => {
      t.equals(el.innerHTML.trim(), '"back" is 2 steps from "book"', 'scripts are imported and executed')
      t.end()
    })
  })
</script>


<!--
## Add events with `<script $on...>`

To add an `click` event listener to your component, write the code inside a
`<script $onclick>...</script>`, like this:

```html
<template $name="count-items" count:number="0" step:number="2">
  Click to count ${count} items in steps of ${step}.
  <script $onclick>
    this.count += step
  </script>
</template>
```

When you add the component to your page:

```html
<count-items></count-items>
```

... it renders this output:

![Click event demo](docs/img/count-items.gif)

To add a `click` event listener **to a child**, use `<script $onclick $select="child-selector">...</script>`:

```html
<template $name="count-button" count:number="0" step:number="2">
  <button>Click here</button>
  <span>Count: ${count}</span>
  <script $onclick="button">
    this.count += step
  </script>
</template>
```

Now, `<count-button></count-button>` renders:

![Click event on child demo](docs/img/count-button.gif)

Listener functions can use these variables:

- `e` is the [event object](https://developer.mozilla.org/en-US/docs/Web/API/Event)
- `this` is the component instance
- All properties, e.g. `count`, `step`

To call the listener only once, add the `$once` attribute to `<script>`:

```html
<template $name="count-once" count:number="0" step:number="2">
  <button>Click here once</button>
  <span>Count: ${count}</span>
  <script $onclick="button" $once>
    this.count += step
  </script>
</template>
```

Now, `<count-once></count-once>` renders:

![$once demo](docs/img/count-once.gif)
-->
<template $name="count-items" count:number="0" step:number="2">
  Click to count ${count} items in steps of ${step}.
  <script $onclick>
    /* globals e, step */
    console.log(e.type.toLowerCase())
    this.count += step
  </script>
</template>
<count-items></count-items>
<script>
  tape('Add events with `<script $onclick>`', function (t) {
    let el = document.querySelector('count-items')
    t.equals(el.innerHTML.trim(), 'Click to count 0 items in steps of 2.', 'count-items base')
    el.click()
    t.equals(el.innerHTML.trim(), 'Click to count 2 items in steps of 2.', 'count-items click 1')
    el.click()
    t.equals(el.innerHTML.trim(), 'Click to count 4 items in steps of 2.', 'count-items click 2')
    t.end()
  })
</script>

<template $name="count-items2" count:number="0" step:number="2">
  Click to count ${count} items in steps of ${step}.
  <script onclick>
    /* globals e, step */
    console.log(e.type.toLowerCase())
    this.count += step
  </script>
</template>
<count-items2></count-items2>
<script>
  tape('Add events with `<script onclick> -- without $ works too`', function (t) {
    let el = document.querySelector('count-items2')
    t.equals(el.innerHTML.trim(), 'Click to count 0 items in steps of 2.', 'count-items2 base')
    el.click()
    t.equals(el.innerHTML.trim(), 'Click to count 2 items in steps of 2.', 'count-items2 click 1')
    el.click()
    t.equals(el.innerHTML.trim(), 'Click to count 4 items in steps of 2.', 'count-items2 click 2')
    t.end()
  })
</script>

<template $name="count-button" count:number="0" step:number="2">
  <button class="button">Click here</button>
  <span>Count: ${count}</span>
  <script $onclick=".button">
    /* globals e, step */
    console.log(e.type.toLowerCase())
    this.count += step
  </script>
</template>
<count-button></count-button>
<script>
  tape('Add events with `<script $onclick="selector">`', function (t) {
    let el = document.querySelector('count-button')
    t.equals(el.querySelector('span').innerHTML.trim(), 'Count: 0', 'count-button base')
    el.querySelector('button').click()
    t.equals(el.querySelector('span').innerHTML.trim(), 'Count: 2', 'count-button click 1')
    el.querySelector('button').click()
    t.equals(el.querySelector('span').innerHTML.trim(), 'Count: 4', 'count-button click 2')
    t.end()
  })
</script>

<template $name="count-once" count:number="0" step:number="2">
  <button>Click here once</button>
  <span>Count: ${count}</span>
  <script $onclick="button" $once>
    this.count += step
  </script>
</template>
<count-once></count-once>
<script>
  tape('Add single listener with `<script $onclick="selector" $once>`', function (t) {
    let el = document.querySelector('count-once')
    t.equals(el.querySelector('span').innerHTML.trim(), 'Count: 0', 'count-once base')
    el.querySelector('button').click()
    t.equals(el.querySelector('span').innerHTML.trim(), 'Count: 2', 'count-once click 1')
    el.querySelector('button').click()
    t.equals(el.querySelector('span').innerHTML.trim(), 'Count: 2', 'count-once click 2')
    t.end()
  })
</script>

<!--
## Use lifecycle events to render components using JavaScript

Components fire these events at different stages of their lifecycle:

- `preconnect`: when the instance is created, but no properties are defined yet
- `connect`: properties are defined, but external scripts may not be loaded
- `prerender`: external scripts are loaded, but template not yet rendered
- `render`: template is rendered

Add `<script onpreconnect>...</script>`, `<script onrender>...</script>`, etc to create listeners.
For example:

```html
<template $name="repeat-events" icon="â˜…" value:number="1">
  <script $onrender>
    this.innerHTML = icon.repeat(value)
  </script>
</template>
```

Now, `<repeat-events icon="â˜…" value="8"><repeat-html>` renders this output:

![8 stars](docs/img/repeat-8-star.png)

Notes:

- You can add a listener to multiple events, like `<script onprerender onrender>`
- You can add multiple listeners to an event, e.g. by repeating `<script onrender>...</script>`
- You can add listeners using `this.addEventListener('render', ...)` too
-->

<template $name="repeat-events" icon="â˜…" value:number="1">
  Hello
  <script src="externalscript.js"></script>
  <script onpreconnect>
    this.preconnect = {
      value: this.$data.value,
      count: this.count,
      content: this.innerHTML.trim()
    }
  </script>
  <script onconnect>
    this.connect = {
      value: this.$data.value,
      count: this.count,
      content: this.innerHTML.trim()
    }
  </script>
  <script onprerender>
    this.prerender = {
      value: this.$data.value,
      count: this.count,
      content: this.innerHTML.trim()
    }
  </script>
  <script onrender>
    /* globals icon, value */
    this.render = {
      value: this.$data.value,
      count: this.count,
      content: this.innerHTML.trim()
    }
    // Listeners can use this (the component) and properties like in templates
    this.innerHTML = icon.repeat(value)
  </script>
  <script onpreconnect onconnect onprerender onrender>
    this.count = (this.count || 0) + 1
  </script>
</template>
<repeat-events icon="â˜…" value="8"></repeat-events>

<script>
  tape('Use lifecycle events to render components using JavaScript', function (t) {
    let el = document.querySelector('repeat-events')
    t.deepEquals(el.preconnect, {value: undefined, count: undefined, content: ''}, 'script preconnect works')
    t.deepEquals(el.connect, {value: 8, count: 1, content: ''}, 'script connect works')
    t.deepEquals(el.prerender, {value: 8, count: 2, content: ''}, 'script prerender works')
    t.deepEquals(el.render, {value: 8, count: 3, content: 'Hello'}, 'script render works')
    t.end()
  })
  tape('Every render triggers a `render` event', function (t) {
    t.plan(3)
    let el = document.querySelector('repeat-events')
    el.addEventListener('render', e => t.equals(e.target.value, 3), { once: true })
    el.value = 3
    el.addEventListener('render', e => t.equals(e.target.value, 4), { once: true })
    el.value = 4
    el.addEventListener('render', e => t.equals(e.target.value, 5), { once: true })
    el.value = 5
  })
</script>


<!--
## Import components with `import="file.html"`

You can save one (or more) component `<template>`s in a HTML file.
For example, `tag.html` could look like this:

```html
<template $name="tag-a">This is tag-a</template>
<template $name="tag-b">This is tag-b</template>
```

To use `<tag-a>` and `<tag-b>` in your HTML file, import it like this:

```html
<script src="node_modules/uifactory/dist/uifactory.min.js" import="tag.html"></script>
```

This uses [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch).
The fetched files must be in the same domain or
[CORS-enabled](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS).

**Multiple component files** are separated by comma and/or spaces. Relative and absolute URLs both work.

```html
<script src="node_modules/uifactory/dist/uifactory.min.js" import="
  tag.html, tag2.html,
  ../test/tag3.html
  https://cdn.jsdelivr.net/npm/uifactory/test/tag4.html
"></script>
```

**Import additional files** via JavaScript if you already added `uifactory.min.js`:

```html
<script>
uifactory.register('tag5.html')
</script>
```
-->
<tag-a></tag-a><tag-b></tag-b>
<script src="../src/uifactory.js" import="tag.html"></script>

<tag2-a></tag2-a>
<tag2-b></tag2-b>
<script src="../src/uifactory.js" import="tag.html, tag2.html"></script>

<tag3-a></tag3-a>
<tag3-b></tag3-b>
<tag4-a></tag4-a>
<tag4-b></tag4-b>
<script src="../src/uifactory.js" import="
  ../test/tag3.html
  https://cdn.jsdelivr.net/npm/uifactory/test/tag4.html
"></script>

<tag5-a></tag5-a>
<tag5-b></tag5-b>
<script>
uifactory.register('tag5.html')
</script>

<script>
  tape('Import components from `import="file.html"`', function (t) {
    let tags = ['tag-a', 'tag-b', 'tag2-a', 'tag2-b', 'tag3-a', 'tag3-b', 'tag4-a', 'tag4-b', 'tag5-a', 'tag5-b']
    t.plan(tags.length)
    tags.forEach(tag => {
      console.log(tag, document.querySelector(tag))
      document.querySelector(tag).$ready.then(function () {
        t.equals(document.querySelector(tag).innerHTML.trim(), `This is ${tag}`, `${tag} is imported`)
      })
    })
  })
</script>


<!--
UIFactory has pre-defined HTML components that you can import, e.g. `<svg-chart>`. To import these,
use `import="@component-name"`.

You can import multiple component files separated by comma and/or spaces.

For example, this imports the `<svg-chart>` and `<md-text>` components:

```html
<script src="node_modules/uifactory/src/uifactory.js" import="@svg-chart @md-text"></script>
```

This is the same as:

```html
<script src="node_modules/uifactory/src/uifactory.js" import="
             node_modules/uifactory/src/svg-chart.html
             node_modules/uifactory/src/md-text.html
"></script>
```

When you add the component to your page:

```html
<md-text>**Strong text** and *italics*</md-text>
```

... it renders this output:

**Strong text** and *italics*
-->

<script src="../src/uifactory.js" import="@svg-chart @md-text"></script>
<md-text>**Strong text** and *italics*</md-text>
<script>
  tape('Import standard components with `import="@component-name"`', function (t) {
    let el = document.querySelector('md-text')
    t.equals(el.innerHTML.trim(), `<p><strong>Strong text</strong> and <em>italics</em></p>`, `md-text imported`)
    t.end()
  })
</script>


<!-- Advanced options -->
<!-- ----------------------------------------------------------------- -->

<!--
## Register component with options

To register a component with full control over the options, use:

```html
<repeat-options value="8"></repeat-options>
<script>
// Add this AFTER the component is defined, not before. Else <slot> contents won't be defined
// See https://github.com/WICG/webcomponents/issues/551
uifactory.register({
  name: 'repeat-options',
  template: '<% for (var j=0; j<+value; j++) { %><slot></slot><% } %>',
  properties: {
    value: { value: "30", type: "number" }
  }
})
</script>
```

The object has these keys:

- `name`: component name, e.g. `"g-repeat"`
- `template`: component contents as a [template](#lodash-templates-are-supported)
- `properties`: OPTIONAL: mapping of [properties](#define-property-types-as-json) as `name: {value, type}` property definitions
- `window`: OPTIONAL: the [Window](https://developer.mozilla.org/en-US/docs/Web/API/Window) on which to register the component. Used to define components on other windows or IFrames
- `compile`: OPTIONAL: the [template compiler](#use-any-compiler) function to use
-->
<repeat-options value="8">â˜…</repeat-options>
<script>
uifactory.register({
  name: 'repeat-options',
  template: '<% for (var j=0; j<+value; j++) { %><slot></slot><% } %>',
  properties: {
    value: { value: "30", type: "number" }
  }
})
</script>
<script>
  tape('Register component with options', function (t) {
    let el = document.querySelector('repeat-options')
    // NOTE: This test NEED NOT WORK if repeat-optons is defined BEFORE it's used
    t.equals(el.innerHTML.trim(), 'â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…', 'uifactory.register() works')
    t.end()
  })
</script>

<!--
## `this.$data[property]` stores all properties

All properties are stored in `this.$data` as an object. You can read and write these values.
For example, this `<print-default>` component changes the default attribute before rendering:

```html
<template $name="print-default" default="old">
  <script onprerender>
    console.log(this.$data)     // Prints { "default": "old" }
    this.$data.default = 'new'  // Updates default value
  </script>
  <%= this.$data.default %>     // renders "new"
</template>
```

Normally, properties are ALSO accessible as `this.<attributeName>`.
But if you define a `<template query-selector="xx">`, will `this.querySelector` be "xx" or the
[this.querySelector()](https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelector) function?

ANS: `this.querySelector` is the function. `this.$data.querySelector` holds "xx".

This is be useful if you don't know whether a property is defined or not.
For example, when you add this to your page:

```html
<template $name="obj-values" x:number="0" y:number="0">
  Properties:
    <% for (let key in this.$data) { %>
      <%= key %>=<%= this.$data[key] %>
    <% } %>
  z=<%= 'z' in this.$data ? 'defined' : 'undefined' %>
</template>
<obj-values x="10" y="20"></obj-values>
```

... it renders this output:

`Properties: x=10 y=20 z=undefined`
-->
<template $name="print-default" default="old">
  <script onprerender>
    console.log(this.$data)     // Prints { "default": "old" }
    this.$data.default = 'new'  // Updates default value
  </script>
  <%= this.$data.default %>
</template>
<print-default></print-default>
<template $name="obj-values" x:number="0" y:number="0">
  Properties:
    <% for (let key in this.$data) { %>
      <%= key %>=<%= this.$data[key] %>
    <% } %>
  z=<%= 'z' in this.$data ? 'defined' : 'undefined' %>
</template>
<obj-values x="10" y="20"></obj-values>
<script>
  tape('`this.$data[property]` stores all properties', function (t) {
    let el = document.querySelector('print-default')
    t.equals(el.innerHTML.trim(), 'new', 'this.$data can be updated')
    el = document.querySelector('obj-values')
    t.equals(el.innerHTML.trim().split(/\s+/).join(' '), 'Properties: x=10 y=20 z=undefined', 'this.$data works')
    t.end()
  })
</script>


<!--
## Create components dynamically

You can dynamically add components at any time. For example:

```html
<div id="parent1"></div>
<script>
  document.querySelector('#parent1').innerHTML = '<repeat-html icon="â˜…" value="8"><repeat-html>'
</script>
```

... adds `<repeat-html icon="â˜…" value="8"><repeat-html>` to the body.

![8 stars](docs/img/repeat-8-star.png)

This code does the same thing:

```html
<div id="parent2"></div>
<script>
  let el = document.createElement('repeat-html')
  el.setAttribute('icon', 'â˜…')
  el.setAttribute('value', '8')
  document.querySelector('#parent2').appendChild(el)
</script>
```
-->

<div id="parent1"></div>
<script>
  document.querySelector('#parent1').innerHTML = '<repeat-html icon="â˜…" value="8"><repeat-html>'
</script>
<div id="parent2"></div>
<script>
  (function () {
    let el = document.createElement('repeat-html')
    el.setAttribute('icon', 'â˜…')
    el.setAttribute('value', '8')
    document.querySelector('#parent2').appendChild(el)
  })()
</script>
<script>
  tape('Create components dynamically', async function (t) {
    let el1 = await document.querySelector('#parent1 repeat-html').$ready
    let el2 = await document.querySelector('#parent2 repeat-html').$ready
    t.equals(el1.innerHTML.trim(), 'â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…', 'create via .innerHTML')
    t.equals(el2.innerHTML.trim(), 'â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…', 'create via .createElement')
  })
</script>


<!--
## Add properties to an instance using types

You can [defining properties on templates](#define-properties-using-template-attr). But you can
add properties on an instance too.

For example, if you have a `<base-component>` with a `base` or `root` attributes like this:

```html
<template $name="base-component" base:number="10" root="">
  Instance properties:
  <% for (let key in this.$data) { %>
    <%= key %>=<%= this.$data[key] %>
  <% } %>
</template>
```

... you can add a custom property when creating the element, by adding a type (e.g. `:number`) like this:

```html
<base-component child:number="20"></base-component>
```

This will render:

```text
Instance properties: base=10 root= child=20
```

The `child` JavaScript variable is now available (as a number).

You can update instance property `.child=...` or the attribute `child:number=`

```html
<script>
  document.querySelector('base-component').child = 30   // Redraw with child=30
  document.querySelector('base-component').setAttribute('child:number', '40')
</script>
```

The instance types **override** the template. For example, here, `base` and `root` are defined as
`:js`, which overrides the template's `base:number`:

```html
<base-component child:number="20" base:js="1 + 2" root:js="2 + 3"></base-component>
```

This will render:

```text
Instance properties: base=3 src=5 child=20
```
-->
<template $name="base-component" base:number="10" root:url="">
  Instance properties:
  <% for (let key in this.$data) { %>
    <%= key %>=<%= this.$data[key] %>
  <% } %>
</template>
<base-component child:number="20">Hello world</base-component>
<base-component child:number="20" base:js="1 + 2" root:js="2 + 3"></base-component>
<script>
  tape('Add properties to an instance using types', function (t) {
    let els = document.querySelectorAll('base-component')
    t.equals(els[0].innerHTML.trim().split(/\s+/).join(' '),
      `Instance properties: base=10 root= child=20`,
      `Instance property added`)
    t.equals(els[1].innerHTML.trim().split(/\s+/).join(' '),
      `Instance properties: base=3 root=5 child=20`,
      `Instance property overrides`)

    function check(t, val) {
      if (els[0].$data.child != val)
        return setTimeout(check, 100, t, val)
      t.equals(els[0].innerHTML.trim().split(/\s+/).join(' '),
        `Instance properties: base=10 root= child=${val}`)
      t.end()
    }
    t.test('Instance property= re-renders', t => {
      els[0].child = 30
      els[0].update()
      check(t, 30)
    })
    t.test('Instance .update({property}) re-renders', t => {
      els[0].update({ child: 35 })
      check(t, 35)
    })
    t.test('Instance attribute= re-renders', t => {
      els[0].setAttribute('child:number', '40')
      check(t, 40)
    })
  })
</script>


<!--
## Add custom types

We define property types on attributes like this: `attr:type="value"`. The default types are
`string` (default), `number`, `boolean`, `array`, `object` or `js`.

You can add a new custom type by extending `uifactory.types`. For example:

```js
uifactory.types.newtype = {
  parse: string => ...,         // Function to convert string to value
  stringify: value => ...       // Function to convert value to string
}
```

Let's add type called `:range`, which creates an array of values:

```js
uifactory.types.range = {
  // Parse a string like seq:range="0,10,2" into [0, 2, 4, 6, 8]
  parse: string => {
    // Pick start, step, end as the first 3 numbers in the string
    let [start, end, step] = string.split(/\D+/)
    // Convert it into an array
    let result = []
    for (let val = (+start || 0); val < (+end || 1); val += (+step || 1))
      result.push(val)
    return result
  },
  // Stringify an array like [0, 2, 4, 6, 8] into "0,10,2"
  stringify: value => {
    let start = value[0]                      // First value, e.g. 0
    let step = value[1] - value[0]            // 2nd - 1st value, e.g. 2
    let end = value[value.length - 1] + step  // Last value + step, e.g. 8 + 2 = 10
    return `${start},${end},${step}`
  }
}
```

When you add a component using this custom type to your page:

```html
<template $name="custom-range" series:range="">
  Values are <%= JSON.stringify(series) %>
</template>
<custom-range series="0,10,2"></custom-range>
```

... it renders this output:

`Values are [0,2,4,6,8]`
-->
<script>
uifactory.types.range = {
  // Parse a string like seq:range="0,10,2" into [0, 2, 4, 6, 8]
  parse: string => {
    // Pick start, step, end as the first 3 numbers in the string
    let [start, end, step] = string.split(/\D+/)
    // Convert it into an array
    let result = []
    for (let val = (+start || 0); val < (+end || 1); val += (+step || 1))
      result.push(val)
    return result
  },
  // Stringify an array like [0, 2, 4, 6, 8] into "0,10,2"
  stringify: value => {
    let start = value[0]                      // First value, e.g. 0
    let step = value[1] - value[0]            // 2nd - 1st value, e.g. 2
    let end = value[value.length - 1] + step  // Last value + step, e.g. 8 + 2 = 10
    return `${start},${end},${step}`
  }
}
</script>
<template $name="custom-range" series:range="">
  Values are <%= JSON.stringify(series) %>
</template>
<custom-range series="0,10,2"></custom-range>
<script>
  tape('Add custom types', function (t) {
    let el = document.querySelector('custom-range')
    t.equals(el.innerHTML.trim(), 'Values are [0,2,4,6,8]')
    t.end()
  })
</script>


<!--
## Custom types need a parse and stringify function

Each [custom type](#add-custom-types) you add to `uifactory.types` needs a `parse` and `stringify`
functions with the following signature:

- `parse(string, name, data)`: Converts the attribute `name:type="string"` into the property `el.$data.name`
  - `string`: string value of the attribute
  - `name`: name of the attribute. (Property names are in camelCase. This is in kebab-case)
  - `data`: all properties of the component, computed so far
- `stringify(value, name, data)`: Converts the property `el.$data.name == value` into a attribute value string
  - `value`: JavaScript object holding the property value
  - `name`: name of the attribute. (Property names are in camelCase. This is in kebab-case)
  - `data`: all properties of the component, computed so far

It can be quite useful to have all properties available as `data`. This lets you parse attributes
based on previous attributes.

For example, let's create a `:formula` type that executes JavaScript. For example:

```js
uifactory.types.formula = {
  // Compile string into a JavaScript function, call it with data, return the result
  parse: (string, name, data) => {
    let fn = new Function('data', `with (data) { return (${string}) }`)
    return fn(data)
  },
  // Just convert the value into a JSON string
  stringify: value => JSON.stringify(value)
}
```

When you add a component using this custom type to your page:

```html
<template $name="custom-formula" x:number="0">
  x=<%= x %>, y=<%= y %>, z=<%= z %>
</template>
<custom-formula x="10" y:formula="x * x" z:formula="2 * y + x"></custom-formula>
```

... it renders this output:

`x=10, y=100, z=210`

The `:formula` type evaluates values in the context of previous values.
-->
<script>
uifactory.types.formula = {
  // Compile string into a JavaScript function, call it with data, return the result
  parse: (string, name, data) => {
    let fn = new Function('data', `with (data) { return (${string}) }`)
    return fn(data)
  },
  // Just convert the value into a JSON string
  stringify: value => JSON.stringify(value)
}
</script>
<template $name="custom-formula" x:number="0">
  x=<%= x %>, y=<%= y %>, z=<%= z %>
</template>
<custom-formula x="10" y:formula="x * x" z:formula="2 * y + x"></custom-formula>

<script>
  tape('Custom types need a parse and stringify function', function (t) {
    let el = document.querySelector('custom-formula')
    t.equals(el.innerHTML.trim(), 'x=10, y=100, z=210', ':formula works')
    t.end()
  })
</script>

<!--
## Check if ready with `.$ready`

You can check if a component is ready (i.e. rendered for the first time), using the
`.$ready` Promise. For example, this component uses an external script. It may time to
get read.

```html
<template $name="text-diff2" x="" y="">
  ${x} is <strong>${uifactory.textDiff2.distance(x, y)} steps</strong> from ${y}
  <script src="https://cdn.jsdelivr.net/npm/levenshtein@1.0.5/lib/levenshtein.js"></script>
  <script>
    // By convention, we add any JS related to a component under uifactory.<componentName>
    uifactory.textDiff2 = {
      distance: (x, y) => (new Levenshtein(x, y)).distance
    }
  </script>
</template>

<text-diff2 x="back" y="book"></text-diff>
```

When check if it has been ready, use:

```js
  let el = await document.querySelector('text-diff2').$ready
  // The <strong> child will be present only after the component is ready.
  el.querySelector('strong').style.color = 'red'
```

It turns the `<strong>` element red when it's ready:

![When ready, element is rendered](docs/img/text-diff2.png)
-->
<template $name="text-diff2" x="" y="">
  ${x} is <strong>${uifactory.textDiff2.distance(x, y)} steps</strong> from ${y}
  <script src="https://cdn.jsdelivr.net/npm/levenshtein@1.0.5/lib/levenshtein.js"></script>
  <script>
    /* globals Levenshtein */
    // By convention, we add any JS related to a component under uifactory.<componentName>
    uifactory.textDiff2 = {
      distance: (x, y) => (new Levenshtein(x, y)).distance
    }
  </script>
</template>

<text-diff2 x="back" y="book"></text-diff2>


<script>
  tape('Check if ready with `.$ready`', async function (t) {
    let el = await document.querySelector('text-diff2').$ready
    // The <strong> child will be present only after the component is ready.
    el.querySelector('strong').style.color = 'red'
    t.equals(el.querySelector('strong').style.color, 'red', '.$ready works')
  })
</script>


<!--
## Get registered components from `uifactory.components`

If you register a `<ui-config>` component, `uifactory.components['ui-config']` has the component's
configuration, i.e. its name, properties, template, and any other options used to register the
component.

For example, this component renders its own configuration.

```html
<template $name="ui-config" str="x" arr:array="[3,4]" expr:js="3 + 2">
  <%= JSON.stringify(uifactory.components['ui-config']) %>
</template>
```

When you add the component to your page:

```html
<ui-config></ui-config>
```

... it renders this output:

```json
{
  "name": "ui-config",
  "properties": {
    "str": {
      "type": "string",
      "value": "x"
    },
    "arr": {
      "type": "array",
      "value": "[3,4]"
    },
    "expr": {
      "type": "js",
      "value": "3 + 2"
    }
  },
  "template": "\n <%= JSON.stringify(uifactory.components['ui-config']) %>\n"
}
```
-->

<template $name="ui-config" str="x" arr:array="[3,4]" expr:js="3 + 2">
  <%= JSON.stringify(uifactory.components['ui-config']) %>
</template>
<ui-config></ui-config>

<script>
  tape('Get registered components from `uifactory.components`', function (t) {
    let el = document.querySelector('ui-config')
    t.equals(uifactory.unescape(el.innerHTML.trim()).replace(/\s+/g, ''), JSON.stringify(
      {
        "name": "ui-config",
        "properties": {
          "str": {
            "type": "string",
            "value": "x"
          },
          "arr": {
            "type": "array",
            "value": "[3,4]"
          },
          "expr": {
            "type": "js",
            "value": "3 + 2"
          }
        },
        "template": "\n <%= JSON.stringify(uifactory.components['ui-config']) %>\n",
      }
    ).replace(/\s+/g, ''))
    t.end()
  })
</script>


<!--
## Use any renderer

Gramex renders the generated HTML into a node by setting `node.innerHTML = html`.
This removes all existing DOM elements and creates new ones.

This is not good if you have event handlers, or want animations. For example, if you want to
rescale a chart's axis smoothly without re-drawing.

You can instead specify a custom `$render:js="myfunction"` where `myfunction(node, html)` updates
the `node` in any way.

For example, here's an SVG component that smoothly animates

```html
<template $name="move-circle" x="0" $render:js="uifactory.moveCircle">
  <svg width="400" height="100" fill="#eee">
    <circle cx="<%= x %>" cy="50" r="30" fill="red"></circle>
  </svg>
  <style>
    move-circle circle {
      transition: all 0.5s ease;
    }
  </style>
  <script>
    // Define a moveCircle function that accepts node as the first parameter.
    // It's called whenever the component is created or updated
    uifactory.moveCircle = function (node, html) {
      let circle = node.querySelector('circle')
      // The first time, it has no child circle. So set the HTML
      if (!circle)
        node.innerHTML = html
      // After that, don't redraw. Update the circle
      else
        node.querySelector('circle').setAttribute('cx', node.$data.x)
    }
  </script>
</template>
<move-circle x="100"></move-circle>
```

Now, suppose you change the circle's color programmatically and then change the `x=""` attribute:

```html
<script>
  document.querySelector('move-circle circle').setAttribute('fill', 'blue')
  document.querySelector('move-circle circle').setAttribute('x', '200')
</script>
```

... the circle is not redrawn. It stays blue. It smoothly moves to `x="200"`.
-->
<template $name="move-circle" x="0" $render:js="uifactory.moveCircle">
  <svg width="400" height="100" fill="#eee">
    <circle cx="<%= x %>" cy="50" r="30" fill="red"></circle>
  </svg>
  <style>
    move-circle circle {
      transition: all 0.5s ease;
    }
  </style>
  <script>
    // Define a moveCircle function that accepts node as the first parameter.
    // It's called whenever the component is created or updated
    uifactory.moveCircle = function (node, html) {
      let circle = node.querySelector('circle')
      // The first time, it has no child circle. So set the HTML
      if (!circle)
        node.innerHTML = html
      // After that, don't redraw. Update the circle
      else
        node.querySelector('circle').setAttribute('cx', node.$data.x)
    }
  </script>
</template>
<move-circle x="100"></move-circle>
<script>
  tape('Use any renderer', function (t) {
    let el = document.querySelector('move-circle circle')
    t.equals(el.getAttribute('fill'), 'red')
    el.setAttribute('fill', 'blue')
    el.setAttribute('x', '200')
    t.equals(el.getAttribute('fill'), 'blue')
    t.equals(el.getAttribute('x'), '200')
    t.end()
  })
</script>

<template $name="event-scripts" x="20">
  <script onrender onpreconnect onprerender>
    /* globals x */
    if (typeof x != 'undefined')
      this.innerHTML = x.repeat(20)
  </script>
</template>

<event-scripts x="ok">...</event-scripts>

<template $name="style-scoped">
  <style scoped>
    h1 { color: red; }
  </style>
  <h1>In red</h1>
</template>


<script src="works-even-with-missing-script">
  // If there's a missing script, ensure that tests are not disrupted because of delays in load
</script>

<script>
  // Run tests after all scripts are loaded
  __tests.forEach(([msg, fn]) => __tape(msg, fn))
  // server.js needs a renderComplete to know that the tests are done
  __tape.onFinish(function () {
    window.renderComplete = true
  })
</script>
</body>
</html>
