<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <script src="tape.js"></script>
  <script src="../src/uifactory.js"></script>
</head>
<body>
  <h1>UIFactory tests</h1>

  <script>
    /* globals tape */
    // Don't run the tests upfront. Run them after all scripts are loaded. Just cache them for now.
    // Component rendering happens asynchronously
    let __tape = tape
    let __tests = []
    // eslint-disable-next-line no-global-assign
    tape = function (msg, fn) {
      __tests.push([msg, fn])
    }
    const renderEvents = {}
    document.body.addEventListener('render', function (e) {
      const tag = e.target.tagName.toLowerCase()
      const id = e.target.getAttribute('id')
      const key = tag + (id ? '#' + id : '')
      renderEvents[key] = renderEvents[key] || []
      renderEvents[key].push({e: e, html: e.target.innerHTML})
    })
  </script>

<!--

This documentation is synchronised with README.md.
Every section is copied as a comment.
It is followed by a test case that proves every statement in that section.

-->

<!--
## Install from npm

Using [npm](https://www.npmjs.com/get-npm):

```bash
npm install uifactory
```

To include it in your script, use

```html
<script src="node_modules/uifactory/src/uifactory.js"></script>
```
-->
<script>
  tape('uifactory is available as globals', function (t) {
    t.ok(uifactory, 'uifactory loaded')
    t.end()
  })
</script>


<!--
## `<template $name="...">` creates components as HTML templates

To create this `<repeat-html>` component, add a `<template $name="repeat-html">` like this:

```html
<template $name="repeat-html" icon="X" value="30">
  ${icon.repeat(+value)}
</template>
```

When you add the component to your page:

```html
<repeat-html icon="â˜…" value="8"></repeat-html>
```

... it renders this output:

![8 stars](img/repeat-8-star.png)

This uses [template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
inside the `<template>` to generate the HTML.

NOTE:

- You **MUST** have a dash (hyphen) in the component name (e.g. `repeat-html`).
  [It's a standard](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements).
- If the `<template>` is empty, the instance contents are used instead.
-->
<template $name="repeat-html" icon="X" value="30">
  ${icon.repeat(+value)}
</template>
<repeat-html icon="â˜…" value="8"></repeat-html>
<script>
  tape('Components use template literals', function (t) {
    let el = document.querySelector('repeat-html')
    t.equals(el.innerHTML.trim(), 'â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…', 'template literals work')
    t.end()
  })
</script>
<script>
  tape('You **MUST** have a dash (hyphen) in the component name', function (t) {
    try {
      uifactory.register({ name: 'nohyphen', 'template': 'xx' })
      t.end('Component name without hyphens allowed!')
    } catch(e) {
      t.equals(e.name, 'SyntaxError', 'Component name without hyphen disallowed')
    }
    t.end()
  })
</script>
<template $name="empty-component" value="">
  <style>empty-component { color: red; }</style>
  <script $onclick>console.log(this)</script>
  <script>console.log('empty-component')</script>
</template>
<empty-component value="OK">${value}</empty-component>
<script>
  tape('If the `<template>` is empty, the instance contents are used instead.', function (t) {
    let el = document.querySelector('empty-component')
    t.equals(el.innerHTML, 'OK', 'instance content is a template')
    t.end()
  })
</script>

<!--
## Lodash templates are supported

For better control, you can use [Lodash templates](https://lodash.com/docs/#template) like this:

```html
<template $name="repeat-template" value="30" icon="â˜…">
  <% for (var j=0; j < +value; j++) { %>
    <%= icon %>
  <% } %>
</template>
```

When you add the component to your page:

```html
<repeat-template value="8" icon="â˜…"></repeat-template>
```

... it renders this output:

![8 stars](docs/img/repeat-8-star.png).

There are 3 kinds of template tags you can use:

1. **`<% ... %>` evaluates JavaScript**. e.g., `<% console.log('ok') %>` logs `ok`
2. **`<%= ... %>` renders JavaScript**. e.g., ``<%= `<b>${2 + 3}</b>` %>`` renders **5** in bold
3. **`<%- ... %>` renders JavaScript, HTML-escaped**. e.g., ``<%- `<b>${2 + 3}</b>` %>`` renders `<b>5</b>` in bold
-->
<template $name="repeat-template" value="30" icon="â˜…">
  <% for (var j=0; j < +value; j++) { %>
    <%= icon %>
  <% } %>
</template>
<repeat-template value="8" icon="â˜…"></repeat-template>
<script>
  tape('Components use templates', function (t) {
    let el = document.querySelector('repeat-template')
    t.ok(el.innerHTML.trim().match(/^(â˜…\s*){8}$/), 'templates work')
    t.end()
  })
  tape('Templates work as expected', function (t) {
    let tmpl = uifactory.template
    t.equals(tmpl('<% print(x + y) %>')({x: 2, y: 3}), '5', 'template evaluation works')
    t.equals(tmpl('<%= `<b>${x + y}</b>` %>')({x: 2, y: 3}), '<b>5</b>', 'template interpolation works')
    t.equals(tmpl('<%- `<b>${x + y}</b>` %>')({x: 2, y: 3}), '&lt;b&gt;5&lt;/b&gt;', 'template escaping works')
    t.end()
  })
</script>


<!--
## Add dynamic classes and styles with `:=`

For dynamic classes, set the `class:=` attribute to a array, object, or string:

- `class:="['x', 'y']"` becomes `class="x y"`
- `class:="{x: true, y: false}"` becomes `class="x"`
- `class:="['x', {y: true, z: false}]"` becomes `class="x y"`
- `class:="${active ? 'yes' : 'no'}"` becomes `class="yes"` is active is true, else `class="no"`

For dynamic styles, set the `style:=` attribute to an object or string:

- ``style:="{'font-size': `${size}px`, color: 'red'}"`` becomes `style="font-size:20px;color:red"` (when size=20).
- `style:="font-size="${size}px; color: red"` also becomes `style="font-size:20px;color:red"` (when size=20).

For dynamic attributes, set the `<attr>:=` attribute to any string or boolean expression:

- `disabled:="true"` becomes "disabled"
- `disabled:="false"` does not add the disabled attribute
- `type:="isNumeric ? 'number' : 'text'"` sets `type="number"` if isNumeric is truthy, else `type="text"`

For example, this defines an `<add-class>` component:

```html
<template $name="custom-input" disabled:boolean="true" type:string="text" min:number="0">
  <style>
    .round { border-radius: 20px; }
    .active { border: 1px solid red; }
  </style>
  <input
    disabled:="disabled"
    type:="type"
    min:="min"
    class:="['round', {active: !disabled}]"
    style:="{'background-color': disabled ? 'white' : 'lightblue'}"
  >
</template>
```

When you add this to your page:

```html
Active: <custom-input disabled="false" type="number" min="0"></custom-input>
Inactive: <custom-input disabled="true"></custom-input>
```

... it renders:

![Output of custom-input](docs/img/custom-input.png)
-->

<template $name="custom-input" disabled:boolean="true" type:string="text" min:number="0">
  <style>
    .round { border-radius: 20px; }
    .active { border: 1px solid red; }
  </style>
  <input
    disabled:="disabled"
    type:="type"
    min:="min"
    class:="['round', {active: !disabled}]"
    style:="{'background-color': disabled ? 'white' : 'lightblue'}"
  >
</template>
Active: <custom-input disabled="false" type="number" min="0"></custom-input>
Inactive: <custom-input disabled="true"></custom-input>
<custom-input disabled:js="null"></custom-input>
<custom-input disabled:js="undefined"></custom-input>
<script>
  tape('Add dynamic classes and styles with `:=`', function (t) {
    let els = document.querySelectorAll('custom-input input')
    t.ok(els[0].classList.contains('round'), 'class:= list works')
    t.ok(els[0].classList.contains('active'), 'class:= object works')
    t.equals(els[0].style.backgroundColor, 'lightblue', 'style:= object works')
    t.equals(els[0].disabled, false, 'disabled:= boolean works')
    t.equals(els[0].type, 'number', 'type:= works')
    t.equals(els[0].min, '0', 'min:= number works -- zero is not false')

    t.ok(els[1].classList.contains('round'), 'class:= list works')
    t.not(els[1].classList.contains('active'), 'class:= object works')
    t.equals(els[1].style.backgroundColor, 'white', 'style:= object works')
    t.equals(els[1].disabled, true, 'disabled:= boolean works')

    t.equals(els[2].getAttribute('disabled'), null, 'disabled:= null works')
    t.equals(els[3].getAttribute('disabled'), null, 'disabled:= undefined works')

    t.end()
  })
</script>

<template $name="dynamic-attrs" bool:boolean="true" int:number="2" str:string="ok" val:string="a<b">
  <div :="{
      'class': ['a', int > 1 ? 'b' : '', {[str]: bool}],
      style: {width: 0, color: int > 1 ? 'red' : null, border: '1px solid red'},
      never: int < 0,
      big: int >= 1,
      val: val
    }"
  ></div>
  <div class:="['a', int > 1 ? 'b' : '', {[str]: bool}]"
    style:="{width: 0, color: int > 1 ? 'red' : null, border: '1px solid red'}"
    never:="int < 0"
    big:="int >= 1"
    val:="val"></div>
  <section class:="['a', 'b'].join(' ')" style:="`width:${int}px`"></section>
</template>
<dynamic-attrs int="2"></dynamic-attrs>
<dynamic-attrs int="0"></dynamic-attrs>
<script>
  tape('Add dynamic classes and styles with `:=`', function (t) {
    let el
    for (el of document.querySelectorAll('dynamic-attrs[int="2"] div')) {
      t.equals(el.getAttribute('class'), 'a b ok', 'int=2 class:=')
      t.equals(el.getAttribute('style'), 'width:0;color:red;border:1px solid red', 'int=2 style:=')
      t.equals(el.getAttribute('never'), null, 'int=2 never:=')
      t.equals(el.getAttribute('big'), '', 'int=2 big:=')
      t.equals(el.getAttribute('val'), 'a<b', 'int=2 val:=')
    }
    for (el of document.querySelectorAll('dynamic-attrs[int="0"] div')) {
      t.equals(el.getAttribute('class'), 'a ok', 'int=0 class:=')
      t.equals(el.getAttribute('style'), 'width:0;border:1px solid red', 'int=0 style:=')
      t.equals(el.getAttribute('never'), null, 'int=0 never:=')
      t.equals(el.getAttribute('big'), null, 'int=0 big:=')
      t.equals(el.getAttribute('val'), 'a<b', 'int=0 val:=')
    }
    el = document.querySelector('dynamic-attrs[int="0"] section')
    t.equals(el.getAttribute('class'), 'a b', 'int=0 string class:=')
    t.equals(el.getAttribute('style'), 'width:0px', 'int=0 string style:=')
    t.end()
  })
</script>

<!--
## `<slot>` inserts contents from the instance

[Slots](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots)
let you create components in which component users can change content.

For example, this defines a component with 2 slots:

```html
<template $name="slot-translate">
   Good = <slot name="good">...</slot>.
   Bad = <slot name="bad">...</slot>.
</template>
```

When you add the component to your page:

```html
<slot-translate>
  <span slot="good"><em>bon</em></span>
  <span slot="bad"><strong>mauvais</strong></span>
</slot-translate>
```

... it renders this output:

Good = *bon*. Bad = **mauvais**.

- `<slot name="good">` is replaced with all `slot="good"` elements.
- `<slot name="bad">` is replaced with all `slot="bad"` elements.
- `<slot>` (without `name=`) is replaced with the whole `<slot-translate>` contents.

Slots can [contain variables](#lodash-templates-are-supported) like `${x}`. This
lets component users customize the component further.

Slot contents are also available as `this.$slot[slotName]`. `${this.$slot.good}` is the same as
`<slot name="good"></slot>`
-->
<template $name="slot-translate">
   Good = <slot name="good">...</slot>.
   Bad = <slot name="bad">...</slot>.
</template>
<slot-translate>
  <span slot="good"><em>bon</em></span>
  <span slot="bad"><strong>mauvais</strong></span>
</slot-translate>
<script>
  tape('Use `<slot>` in templates', function (t) {
    let el = document.querySelector('slot-translate')
    t.ok(el.innerHTML.match(/Good = <span slot="good"><em>bon<\/em><\/span>./), 'Slot "good" rendered')
    t.ok(el.innerHTML.match(/Bad = <span slot="bad"><strong>mauvais<\/strong><\/span>./), 'Slot "bad" rendered')
    t.end()
  })
</script>

<template $name="repeat-slots" a="1" b="1">
  <% for (var j=0; j < +a; j++) { %>
    <slot
          NAME =   'a' >A</slot
    >
  <% } %>
  <% for (var j=0; j < +a; j++) { %>
    <slot name="b">B</slot>
  <% } %>
  <slot></slot>
  ${this.$slot.a} ${this.$slot.b} ${this.$slot['']}
</template>
<repeat-slots a="5" b="5">
  prefix
  <span slot="a">ðŸ”´</span>
  <span slot="b">ðŸŸ©</span>
  <span slot="a"><strong>${j}</strong></span>
  <span slot="b"><em>${j + 1}</em></span>
  suffix
</repeat-slots>
<script>
  tape('Slots are supported', function (t) {
    let el = document.querySelector('repeat-slots')
    t.equals(el.innerText.trim(), 'ðŸ”´0 ðŸ”´1 ðŸ”´2 ðŸ”´3 ðŸ”´4 ðŸŸ©1 ðŸŸ©2 ðŸŸ©3 ðŸŸ©4 ðŸŸ©5 prefix ðŸ”´ ðŸŸ© 5 6 suffix ðŸ”´${j} ðŸŸ©${j + 1} prefix ðŸ”´ ðŸŸ© ${j} ${j + 1} suffix', 'Slots rendered')
    t.equals(el.querySelectorAll('strong').length, 8, 'Child HTML element <strong> copied')
    t.equals(el.querySelectorAll('em').length, 8, 'Child HTML element <em> copied')
    t.end()
  })
</script>


<!--
## Wrap tables in `<script type="text/html">`

HTML doesn't allow `<% for ... %>` inside a `<tbody>`. (Only `<tr>` is allowed.) So this is invalid:

```html
<template $name="table-invalid" rows="3">
  <table>
    <tbody>
      <% for (let i=0; i < +rows; i++) { %>
        <tr><td>Row <%= i %></td></tr>
      <% } %>
    </tbody>
  </table>
</template>
```

To avoid this, wrap tables inside a `<script type="text/html">...</script>`.
Anything inside it is rendered as a template. (Any HTML outside it is ignored.)

```html
<template $name="table-valid" rows="0">
  This text is ignored!
  <script type="text/html">
    <table>
      <tbody>
        <% for (let i=0; i < +rows; i++) { %>
          <tr><td>Row <%= i %></td></tr>
        <% } %>
      </tbody>
    </table>
  </script>
  This text is ignored too!
</template>
<table-valid rows="3"></table-valid>
```
-->
<template $name="table-valid" rows="0">
  This text is ignored!
  <script type="text/html">
    <table>
      <tbody>
        <% for (let i=0; i < +rows; i++) { %>
          <tr><td>Row <%= i %></td></tr>
        <% } %>
      </tbody>
    </table>
  </script>
  This text is ignored too!
</template>
<table-valid rows="3"></table-valid>
<script>
  tape('Wrap tables in HTML scripts', function (t) {
    let el = document.querySelector('table-valid')
    // TODO: BRITTLE test. Fails sometimes
    t.equals(el.querySelectorAll('table > tbody > tr').length, 3, 'HTML scripts rendered')
    t.ok(!el.innerHTML.match(/ignored/), 'non-script content ignored')
    t.end()
  })
</script>


<!--
## Add re-usable blocks with `<script type="text/html" $block="...">`

To re-use HTML later, add it into a `<script type="text/html" $block="blockname">...</script>`. For example:

```html
<template $name="block-example" greeting="hello">
  <script type="text/html" $block="one">one says ${greeting}.</script>
  <script type="text/html" $block="two">two says ${greeting}.</script>

  <%= one() %>
  <%= two({ greeting: 'Ola' }) %>
</template>
```

When you add the component to your page:

```html
<block-example></block-example>
```

... it renders this output:

```text
one says hello. two says Ola.
```

Note:

- You can use [`this`](#access-component-as-this-inside-templates) and
  [all properties](#access-properties-as-variables-inside-templates) as variables.
- If multiple `<script type="text/html">` have the same `$block` value, the last one is used
-->
<template $name="block-example" greeting="hello">
  <script type="text/html" $block="one">one says ${greeting}.</script>
  <script type="text/html" $block="two">two says ${greeting}.</script>

  <%= one() %>
  <%= two({ greeting: 'Ola' }) %>
</template>
<block-example></block-example>
<script>
  tape('Add re-usable blocks with `<script type="text/html" $block="...">``', function (t) {
    let el = document.querySelector('block-example')
    t.equals(el.innerText.trim(), 'one says hello. two says Ola.', '$block rendered')
    t.end()
  })
</script>

<template $name="repeat-block" value="8" icon="â˜…">
  <!-- $block="wrap" defines a wrap() function that returns this HTML, rendered -->
  <script type="text/html" $block="wrap">
    <span style="border: 1px solid ${color}"><%- icon.repeat(+value) %></span>
  </script>
  <!-- Use wrap() anywhere in the component -->
  <% if (+value % 2 == 0) { %>
    Even â–¸ <%= wrap({ ...this.$data, color: 'red' }) %>
  <% } else { %>
    <%= wrap({ ...this.$data, color: 'blue' }) %> â—‚ Odd
  <% } %>
</template>
<repeat-block value="2"></repeat-block>
<repeat-block value="3"></repeat-block>
<script>
  tape('Create re-usable blocks with `<script type="text/html" $block="...">`', function (t) {
    let els = document.querySelectorAll('repeat-block')
    t.equals(els[0].innerText.trim(), 'Even â–¸ â˜…â˜…', '$block rendered')
    t.equals(els[1].innerText.trim(), 'â˜…â˜…â˜… â—‚ Odd', '$block rendered')
    t.end()
  })
</script>

<template $name="test-block" x="1" y="2">
  <script type="text/html" $block="a">ignored because it's a duplicate</script>
  <script type="text/html" $block="b">ignored because it's a duplicate</script>
  <script type="text/html" $block="a">x=${x} y=${y} z=${obj.z || 'na'} this.x=${this.x}</script>
  <script type="text/html" $block="b"><%= a(obj).replace(/\s/g, ',') %></script>
  <span class="a"><%= a() %></span>
  <span class="a-x3"><%= a({ x: 3 }) %></span>
  <span class="a-x3z4"><%= a({ x: 3, z: 4 }) %></span>
  <span class="b"><%= b() %></span>
  <span class="b-x3"><%= b({ x: 3 }) %></span>
  <span class="b-x3z4"><%= b({ x: 3, z: 4 }) %></span>
</template>
<test-block></test-block>
<script>
  tape('Test re-usable blocks variable binding`', function (t) {
    t.equals(document.querySelector('test-block .a').innerHTML, 'x=1 y=2 z=na this.x=1', 'test-block .a')
    t.equals(document.querySelector('test-block .a-x3').innerHTML, 'x=3 y=2 z=na this.x=1', 'test-block .a-x3')
    t.equals(document.querySelector('test-block .a-x3z4').innerHTML, 'x=3 y=2 z=4 this.x=1', 'test-block .a-x3z4')
    t.equals(document.querySelector('test-block .b').innerHTML, 'x=1,y=2,z=na,this.x=1', 'test-block .a')
    t.equals(document.querySelector('test-block .b-x3').innerHTML, 'x=3,y=2,z=na,this.x=1', 'test-block .a-x3')
    t.equals(document.querySelector('test-block .b-x3z4').innerHTML, 'x=3,y=2,z=4,this.x=1', 'test-block .a-x3z4')
    t.end()
  })
</script>


<!--
## Define properties using `<template attr="...">`

Attributes added to `<template>` can be accessed as properties.
For example, this defines 2 attributes, `icon=` and `value=`:

```html
<template $name="repeat-icon" icon="â˜…" value="30">
  ${icon.repeat(+value)}
</template>
```

Now, you can use `el.icon` and `el.value` to get and set these attributes.

```html
<script>
let el = document.querySelector('repeat-icon')  // Find first <repeat-icon>
console.log(el.icon)                            // Logs â˜…
console.log(el.value)                           // Logs 30
el.value = 10                                   // Renders â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…
</script>
```

![Access and change properties](docs/img/g-repeat-properties.gif)

Setting a property, e.g. `.value = ...` *re-renders* the component.
So does `.setAttribute('value', ...)`.

Notes:

- Attributes with uppercase letters (e.g. `fontSize`) are converted to lowercase properties (e.g. `fontsize`)
- Attributes with a dash/hyphen (e.g. `font-size`) are converted to *camelCase* properties (e.g. `fontSize`).
- Attributes not in the template are **NOT** properties, even if you add them in the component (e.g. `<my-component extra="x">` does not define a `.extra`).
- But [attributes with types (e.g. `extra:string="x"`) are available as properties](#add-properties-to-an-instance-using-types).
- Properties that cannot be variable names (e.g. `default=""`) can be accessed via [`this.$data`]((#thisdataproperty-stores-all-properties)) (e.g. `this.$data['default']`).
-->
<template $name="attr-test" mixedCase="mc" font-size="fs" query-selector="qs"></template>
<attr-test mixedCase="MC" font-size="FS" extra="E" query-selector="QS"></attr-test>
<script>
  tape('Define properties using template attributes', function (t) {
    let el = document.querySelector('repeat-html')  // Find first <repeat-html>
    t.ok(el.icon, 'Attributes on template are added as properties')
    t.ok(el.value, 'Attributes on template are added as properties')

    el.value = 10
    t.equals(el.innerHTML.trim(), 'â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…', 'Changing a property via via `.value = ...` *re-renders* the component.')

    el.setAttribute('value', "4")
    t.equals(el.innerHTML.trim(), 'â˜…â˜…â˜…â˜…', 'So does changing it via `.setAttribute()`.')
    t.end()
  })
  let at = document.querySelector('attr-test')
  tape('Attribute names with uppercase letters (e.g. `fontSize`) are converted to lowercase property names (e.g. `fontsize`)', function (t) {
    t.equals(at.mixedcase, 'MC', 'mixed-case attrs become lowercase')
    t.end()
  })
  tape('Attribute names with a dash/hyphen (e.g. `font-size`) are converted to *camelCase* property names (e.g. `fontSize`).', function (t) {
    t.equals(at.fontSize, 'FS', 'hyphenated attributes become camelCase')
    t.end()
  })
  tape('Attributes not in the template are **NOT** properties, even if you add them in the component (e.g. `<g-repeat new-attr="x">`).', function (t) {
    t.equals(at.extra, undefined, 'non-template attributes are not properties')
    t.end()
  })
</script>

<template $name="repeat-value" value:number="30" default:number="20">
  <%= value + this.$data['default'] %>
</template>
<repeat-value value="8" default="2">â˜…</repeat-value>
<script>
  tape('Access properties as variables', function (t) {
    let el = document.querySelector('repeat-value')
    t.ok(el.innerHTML.trim().match(/^10$/), 'properties are available as variables')
    t.end()
  })
</script>


<!--
## Define property types using `<template attr:type="...">`

By default, properties are of type `string`. You can specify `number`, `boolean`, `array`,
`object` or `js` like this:

- `<template $name="..." num:number="30">`
- `<template $name="..." bool:boolean="true">`
- `<template $name="..." arr:array="[3,4]">`
- `<template $name="..." obj:object='{"x":1}'>`
- `<template $name="..." expr:js="Math.ceil(2.2) + num">`

The value for `:js=` can include global variables as well as other properties defined just before this property.

For example, when you add this to your page:

```html
<template $name="property-types" x="" str:string="" num:number="" bool:boolean=""
  arr:array="" obj:object="" expr:js="" rules:js="">
  ${JSON.stringify({x, str, num, bool, arr, obj, expr, rules})}
</template>
<script>
  var rules = {r: 1}
</script>
<property-types x="x" str="y" num="30" bool="true" arr="[3,4]" obj='{"x":1}'
  expr="Math.ceil(2.2) + num + data.num" rules="rules"></property-types>
```

... it renders this output:

```json
{"x":"x","str":"y","num":30,"bool":true,"arr":[3,4],"obj":{"x":1},"expr":63,"rules":{"r":1}}
```
-->

<template $name="property-types" x="" str:string="" num:number="" bool:boolean=""
  arr:array="" obj:object="" expr:js="" rules:js="">
  <%= JSON.stringify({x, str, num, bool, arr, obj, expr, rules}) %>
</template>
<script>
  /* exported rules */
  var rules = {r: 1}
</script>
<property-types x="x" str="y" num="30" bool="true" arr="[3,4]" obj='{"x":1}'
  expr="Math.ceil(2.2) + num + data.num" rules="rules"></property-types>
<property-types></property-types>
<script>
  tape('Define property types using `<template attr:js="...">`', function (t) {
    let el = document.querySelectorAll('property-types')
    t.equals(el[0].innerHTML.trim(), '{"x":"x","str":"y","num":30,"bool":true,"arr":[3,4],"obj":{"x":1},"expr":63,"rules":{"r":1}}', 'property types are parsed correctly')

    el[0].setAttribute('obj', '{x:2}')
    t.equals(el[0].innerHTML.trim(), '{"x":"x","str":"y","num":30,"bool":true,"arr":[3,4],"obj":{"x":1},"expr":63,"rules":{"r":1}}', ':object does not accept invalid JSON')

    el[0].setAttribute('obj', '{"x":2}')
    t.equals(el[0].innerHTML.trim(), '{"x":"x","str":"y","num":30,"bool":true,"arr":[3,4],"obj":{"x":2},"expr":63,"rules":{"r":1}}', ':object can be updated with valid JSON')

    // NOTE: Currently, the default value is an empty string. In the future, this may change.
    // e.g. we may want num: 0, bool: false, arr: [], obj: {}.
    t.equals(el[1].innerHTML.trim(), '{"x":"","str":"","num":"","bool":"","arr":"","obj":"","expr":"","rules":""}')
    t.end()
  })
</script>


<!--
## Fetch URLs as text using the `:urltext` type

To fetch a URL as text, specify `:urltext` as the property type. For example, this `<fetch-text>`
component displays "Loading..." until a URL is loaded, and then displays its text.

```html
<template $name="fetch-text" src:urltext="">
  <% if (src === null) { %>
    Loading...
  <% } else { %>
    <%= src %>
  <% } %>
</template>
<fetch-text src="page.txt"></fetch-text>
```

... it renders the contents of [page.txt](test/page.txt) as text:

```text
Contents of page.txt
```

This component will be **rendered twice** (and fire two `prerender`/`render` events.)

1. The first happens immediately, before loading the URL. `src` is `null`. This is useful to display a "Loading..." sign
2. The second happens after loading the URL. `src` now has the contents as text

To reload the URL and re-render, you can set `.src = 'page.pxt'` or `.update({src: 'page.txt'})`:

```js
document.querySelector('.fetch-text').src = 'page.txt'
// OR
document.querySelector('.fetch-text').update({ src: 'page.txt' })
```

You can set the property to another URL (which is fetched) or a non-string JS object (which is used as-is).
For example:

```js
document.querySelector('.fetch-text').src = 'page2.txt'   // Loads page2.txt, re-renders
document.querySelector('.fetch-text').src = null          // Sets src=null, re-renders
```
-->
<template $name="fetch-text" src:urltext="">
  <% if (src === null) { %>
    Loading...
  <% } else { %>
    <%= src %>
  <% } %>
</template>
<fetch-text src="page.txt"></fetch-text>
<script>
  tape('Fetch URLs as text using the `:urltext` type', function (t) {
    let el = document.querySelector('fetch-text')
    let refreshed = 0
    function check() {
      let events = renderEvents['fetch-text']
      if (events.length == 2 && refreshed == 0) {
        t.equals(el.innerHTML.trim(), 'Contents of page.txt')
        el.src = 'page.txt'
        refreshed = 1
      } else if (events.length == 4 && refreshed == 1) {
        t.equals(el.innerHTML.trim(), 'Contents of page.txt')
        el.update({ src: 'page.txt' })
        refreshed = 2
      } else if (events.length == 6 && refreshed == 2) {
        t.equals(el.innerHTML.trim(), 'Contents of page.txt')
        el.src = 'page2.txt'
        refreshed = 3
      } else if (events.length == 8 && refreshed == 3) {
        t.equals(el.innerHTML.trim(), 'Contents of page2.txt')
        el.src = null
        refreshed = 4
      } else if (events.length == 9 && refreshed == 4) {
        t.equals(el.innerHTML.trim(), 'Loading...')
        return t.end()
      }
      setTimeout(check, 100)
    }
    check()
  })
</script>


<!--
## Fetch URLs as JSON using the `:urljson` type

To fetch a URL as JSON, specify `:urljson` as the property type. For example, this `<fetch-json>`
component displays "Loading..." until a URL is loaded, and then displays its JSON.

```html
<template $name="fetch-json" src:urljson="">
  <% if (src === null) { %>
    Loading...
  <% } else { %>
    <%= JSON.stringify(src) %>
  <% } %>
</template>
<fetch-url src="page.json"></fetch-url>
```

... it renders the contents of [page.json](test/page.json):

```text
{"text":"abc","number":10,"object":{"x":[1,2,3]}}
```

This component will be **rendered twice** (and fire two `prerender`/`render` events.)

1. The first happens immediately, before loading the URL. `src` is `null`. This is useful to display a "Loading..." sign
2. The second happens after loading the URL. `src` now has the contents as JSON

To reload the URL and re-render, you can set `.src = 'page.json'` or `.update({src: 'page.json'})`:

```js
document.querySelector('.fetch-json').src = 'page.json'
// OR
document.querySelector('.fetch-json').update({ src: 'page.json' })
```

You can set the property to another URL (which is fetched) or a non-string JS object (which is used as-is).
For example:

```js
document.querySelector('.fetch-json').src = 'page2.json'  // Loads page2.json, re-renders
document.querySelector('.fetch-json').src = {x: 1}        // Sets src={x:1}, re-renders
```
-->
<template $name="fetch-json" src:urljson="">
  <% if (src === null) { %>
    Loading...
  <% } else { %>
    <%= JSON.stringify(src) %>
  <% } %>
</template>
<fetch-json src="page.json"></fetch-json>
<script>
  tape('Fetch URLs as json using the `:urljson` type', function (t) {
    let el = document.querySelector('fetch-json')
    let refreshed = 0
    function check() {
      let events = renderEvents['fetch-json']
      if (events.length == 2 && refreshed == 0) {
        t.equals(el.innerHTML.trim(), '{"text":"abc","number":10,"object":{"x":[1,2,3]}}')
        el.src = 'page.json'
        refreshed = 1
      } else if (events.length == 4 && refreshed == 1) {
        t.equals(el.innerHTML.trim(), '{"text":"abc","number":10,"object":{"x":[1,2,3]}}')
        el.update({ src: 'page.json' })
        refreshed = 2
      } else if (events.length == 6 && refreshed == 2) {
        t.equals(el.innerHTML.trim(), '{"text":"abc","number":10,"object":{"x":[1,2,3]}}')
        el.src = 'page2.json'
        refreshed = 3
      } else if (events.length >= 8 && refreshed == 3) {
        t.equals(el.innerHTML.trim(), '{"text":"def","number":20,"object":{"x":[4,5,6]}}')
        el.src = { x: 1 }
        refreshed = 4
      } else if (events.length >= 9 && refreshed == 4) {
        t.equals(el.innerHTML.trim(), '{"x":1}')
        return t.end()
      } else {
        return t.end('Invalid state')
      }
      setTimeout(check, 100)
    }
    check()
  })
</script>


<!--
## Fetch URLs using the `:url` type

To fetch a URL as text, specify `:url` as the property type. For example, this `<fetch-page>`
component displays "Loading..." until a URL is loaded, and then displays it.

```html
<template $name="fetch-page" src:url="">
  <% if (src === null) { %>
    Loading...
  <% } else { %>
    <%= src.text %>
  <% } %>
</template>
<fetch-page src="page.txt"></fetch-page>
```

... it renders the contents of [page.txt](test/page.txt):

```text
Contents of page.txt
```

This component will be **rendered twice** (and fire two `prerender`/`render` events.)

1. The first happens immediately, before loading the URL. `src` is `null`. This is useful to display a "Loading..." sign
2. The second happens after loading the URL. `src` now has the contents as
   a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) object with these keys:
   - `.headers`: response [headers](https://developer.mozilla.org/en-US/docs/Web/API/Response/headers)
   - `.status`: HTTP status code
   - `.statusText`: HTTP status message corresponding to the status code (e.g., OK for 200)
   - `.ok`: `true` if the HTTP status is the range 200-299
   - `.url`: The URL of the response -- after any redirections
   - `.text`: Text from the loaded page. This is **not a Promise**, but the actual text
-->
<template $name="fetch-page" src:url="">
  <% if (src === null) { %>
    Loading...
  <% } else { %>
    <%= src.text %>
  <% } %>
</template>
<fetch-page src="page.txt"></fetch-page>
<script>
  tape('Fetch URLs using the `:url` type', function (t) {
    let el = document.querySelector('fetch-page')
    function check() {
      let events = renderEvents['fetch-page']
      if (!events || events.length < 2)
        return setTimeout(check, 100)
      t.ok(el.src.ok)
      t.equals(el.src.status, 200)
      t.ok(el.src.headers.get('Content-Type').match(/text\/plain/))
      t.equals(el.src.text.trim(), 'Contents of page.txt')
      t.equals(el.innerHTML.trim(), 'Contents of page.txt')
      t.end()
    }
    check()
  })
</script>

<!--
## Access component as `this` inside templates

Inside the [template](#lodash-templates-are-supported), `this` refers to the component itself.

For example, this component makes its parent's background yellow.

```html
<template $name="parent-background" color="yellow">
  <% this.parentElement.style.background = color %>
</template>
```

When you add the component to your page:

```html
<div>
  <parent-background></parent-background>
  This has a yellow background
</div>
```

... it renders this output:

![Access `this` element](docs/img/parent-background.png)

This lets you control not just the component, but parents, siblings, and any other elements on a page.
-->
<template $name="parent-background" color="yellow">
  <% this.parentElement.style.background = color %>
</template>
<div id="parent-container">
  <parent-background></parent-background>
  This has a yellow background
</div>
<script>
  tape('Access component as `this`', function (t) {
    t.equals(document.querySelector('#parent-container').style.background, 'yellow', 'this.parentElement works')
    t.end()
  })
</script>


<!--
## Access component contents as `this.$contents`

`this.$contents` is a cloned version of the custom element's original DOM. You can access what the
user specified inside your component and use it in your template.

For example, `<repeat-icons>` repeats everything under `class="x"` x times, and everything under
`class="y"` y times.

```html
<template $name="repeat-icons" x:number="3" y:number="2">
  <%= this.$contents.querySelector('.x').innerHTML.repeat(x) %>
  <%= this.$contents.querySelector('.y').innerHTML.repeat(y) %>
</template>
```

When you add the component to your page:

```html
<repeat-icons x="5" y="4">
  <span class="x">ðŸ™‚</span>
  <span class="y">ðŸ˜¡</span>
</repeat-icons>
```

... it renders this output:

ðŸ™‚ðŸ™‚ðŸ™‚ðŸ™‚ðŸ™‚ðŸ˜¡ðŸ˜¡ðŸ˜¡ðŸ˜¡
-->
<template $name="repeat-icons" x:number="3" y:number="2">
  <%= this.$contents.querySelector('.x').innerHTML.repeat(x) %>
  <%= this.$contents.querySelector('.y').innerHTML.repeat(y) %>
</template>
<repeat-icons x="5" y="4">
  <span class="x">ðŸ™‚</span>
  <span class="y">ðŸ˜¡</span>
</repeat-icons>
<script>
  tape('Access `<template>` as `this`', function (t) {
    let el = document.querySelector('repeat-icons')
    t.ok(el.innerHTML.match(/ðŸ™‚ðŸ™‚ðŸ™‚ðŸ™‚ðŸ™‚\s*ðŸ˜¡ðŸ˜¡ðŸ˜¡ðŸ˜¡/), 'this.$contents.querySelector is accessible')
    t.end()
  })
</script>


<!--
## Update multiple properties with `.update()`

You can change multiple properties together using `.update({'attr-1': val, 'attr-2': val})`. For
example, this component has 2 properties, `char` and `repeat-value`:

```html
<template $name="repeat-props" char="â˜…" repeat-value:number="10">
  ${char.repeat(repeatValue)}
</template>
<repeat-props char="â˜…" repeat-value="10"></repeat-props>
```

After the element is rendered, run this code in your **JavaScript console**:

```js
document.querySelector('repeat-props').update({
  char: 'âš¡',
  'repeat-value': 8       // Note: use 'repeat-value', not repeatValue
})
```

This updates both `char` and `repeat-value` to generate this output:

![update() changes multiple properties](docs/img/repeat-props.png)

`.update()` also updates the attributes and re-renders the component. `.update()` takes a second dict with options:

- `attr: false` does not update the attribute. Default: `true`
- `render: false` does not re-render the component. Default: `true`

For example, this updates the properties without changing the attributes and without re-rendering.

```html
<script>
  document.querySelector('repeat-props').update({
    char: 'âš½',
    'repeat-value': 5
  }, { attr: false, render: false })
</script>
```

To just re-render the component without changing properties, use `.update()`.

```html
<script>
  document.querySelector('repeat-props').update()
</script>
```
-->

<template $name="repeat-props" char="â˜…" repeat-value:number="10">
  ${char.repeat(repeatValue)}
</template>
<repeat-props char="â˜…" repeat-value="10"></repeat-props>
<script>
  tape('Update multiple properties with `.update()`', function (t) {
    let el = document.querySelector('repeat-props')
    el.update({ char: 'âš¡', 'repeat-value': 8 })
    t.equals(el.innerHTML.trim(), 'âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡', '.update() updates both props')
    t.equals(el.getAttribute('char'), 'âš¡', '.update() updates char')
    t.equals(el.getAttribute('repeat-value'), '8', '.update() updates repeat-value')

    el.update({ char: 'âš½', 'repeat-value': 5 }, { attr: false, render: false })
    t.equals(el.innerHTML.trim(), 'âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡', '.update({}, { render: false }) does not render')
    t.equals(el.getAttribute('char'), 'âš¡', '.update({}, { attr: false }) does not set char="" attr')
    t.equals(el.getAttribute('repeat-value'), '8', '.update({}, { attr: false }) does not set repeat-value="" attr')

    el.update()
    t.equals(el.innerHTML.trim(), 'âš½âš½âš½âš½âš½', '.update() re-renders')

    t.end()
  })
</script>

<!--
## Style components with CSS

Use regular CSS in the `<style>` tag to style components. For example:

```html
<template $name="repeat-style" value:number="30">
  <style>
    /* If class="highlight", add a yellow background */
    repeat-style.highlight { background-color: yellow; }
    /* Color all bold items green INSIDE THE COMPONENT */
    b { color: green; }
  </style>
  <% for (var j=0; j < value; j++) { %>
    <slot></slot>
  <% } %>
</template>
```

When you add the component to your page:

```html
<repeat-style class="highlight" value="8">
  <b>â˜…</b>
</repeat-style>
```

... it renders this output:

![Style applied to repeat-style](docs/img/repeat-style.png)

**You can't pollute styles outside the component**. UIFactory adds the component name before every
selector (if it's missing). For example:

- `repeat-style.highlight {...}` stays as-is -- it already has `repeat-style`
- `.highlight b {...}` becomes `repeat-style .highlight b {...}`
- `b { color: green}` becomes `repeat-style b { color:green; }`

So any `<b>` outside the component does not change color.

**Note**: This isn't foolproof. It's simply to prevent accidental pollution.

**You can override component styles from the outside**. UIFactory just copies the `<style>` into the
document -- no shadow DOM. Adding this `<style>` overrides the component color:

```html
<style>
/* Prefixing `body` to `repeat-stye b` for more specificity */
body repeat-style b { color: red; }
</style>

![Red overrides repeat-style's green](docs/img/repeat-style-red.png)
```
-->
<template $name="repeat-style" value:number="30">
  <style>
    /* If class="highlight", add a yellow background */
    repeat-style.highlight { background-color: yellow; }
    /* Color all bold items green INSIDE THE COMPONENT */
    b { color: green; }
  </style>
  <% for (var j=0; j < value; j++) { %>
    <slot></slot>
  <% } %>
</template>
<repeat-style class="highlight" value="8">
  <b>â˜…</b>
</repeat-style>
<style>
body repeat-style.overridden b { color: red; }
</style>
<repeat-style class="highlight overridden" value="8">
  <b>â˜…</b>
</repeat-style>
<b id="outside">Outside</b>

<script>
  tape('Style components with CSS', function (t) {
    let repeatStyle = getComputedStyle(document.querySelector('repeat-style'))
    let innerStyle = getComputedStyle(document.querySelector('repeat-style b'))
    let overridenStyle = getComputedStyle(document.querySelector('repeat-style.overridden b'))
    let outerStyle = getComputedStyle(document.querySelector('b#outside'))
    let headingStyle = getComputedStyle(document.querySelector('body > h1'))
    t.equals(repeatStyle.backgroundColor, 'rgb(255, 255, 0)', 'style is applied on component')
    t.equals(innerStyle.color, 'rgb(0, 128, 0)', 'style is applied inside component')
    t.equals(overridenStyle.color, 'rgb(255, 0, 0)', 'style is overridden from outside')
    t.equals(outerStyle.color, headingStyle.color, 'style is not applied outside component')
    t.end()
  })
</script>

<!--
## Link to external stylesheets

You can link to external stylesheets. For example, this imports Bootstrap 4.6.

```html
<template $name="bootstrap-button" type="primary">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css">
  <button class="btn btn-<%= type %> m-3"><slot></slot></button>
</template>
```

When you add the component to your page:

```html
<bootstrap-button type="success">â˜…</bootstrap-button>
```

... it renders this output:

![Bootstrap button with external style](docs/img/bootstrap-button.png)

All `<style>`s and `<link rel="stylesheet">`s are appended to the document's HEAD. They run only once (even if you use the component multiple times.)
-->
<template $name="bootstrap-button" type="primary">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css">
  <button class="btn btn-<%= type %> m-3"><slot></slot></button>
</template>
<bootstrap-button type="success">â˜…</bootstrap-button>
<script>
  tape('Link to external stylesheets', function (t) {
    let successColor = 'rgb(40, 167, 69)'
    function check() {
      let el = document.querySelector('bootstrap-button > button')
      let bg = el ? getComputedStyle(el).backgroundColor : ''
      if (bg != successColor)
        return setTimeout(check, 200)
      t.equals(bg, successColor, 'external style is applied')
      t.end()
    }
    check()
  })
</script>

<!--
## Override styles normally

UIFactory just copies the HTML into the component. There's no shadow DOM. You can override a component styles normally.

For example, this `<style>` affects buttons inside the component:

```html
<style>
  /* When user hovers on any button inside a repeat-style, color it lime */
  repeat-style.green-hover button:hover {
    background-color: lime;
  }
</style>
<repeat-style class="green-hover" value="5">
  ðŸ™‚<button>â˜…</button>
</repeat-style>
```

... it renders this output:

![repeat-style colors button on hover](docs/img/repeat-style-hover.gif)
-->

<style>
  /* When user hovers on any button inside a repeat-style, or a .lime button, color it lime */
  repeat-style button:hover, repeat-style button.lime {
    background-color: lime;
  }
</style>
<repeat-style class="green-hover" value="5">
  ðŸ™‚<button>â˜…</button>
</repeat-style>
<script>
  tape('Override styles normally', function (t) {
    let el = document.querySelector('repeat-style.green-hover > button')
    el.classList.add('lime')
    t.equals(getComputedStyle(el).backgroundColor, 'rgb(0, 255, 0)', 'style is overridden')
    t.end()
  })
</script>

<!--
## Add behavior with JavaScript

Use regular JavaScript to add logic and interactivity.

```html
<template $name="text-diff" x="" y="">
  "${x}" is ${uifactory.textDiff.distance(x, y)} steps from "${y}"
  <script src="https://cdn.jsdelivr.net/npm/levenshtein@1.0.5/lib/levenshtein.js"></script>
  <script>
    // By convention, we add any JS related to a component under uifactory.<componentName>
    uifactory.textDiff = {
      distance: (x, y) => (new Levenshtein(x, y)).distance
    }
  </script>
</template>
```

When you add the component to your page:

```html
<text-diff x="back" y="book"></text-diff>
```

... it renders this output:

```text
"back" is 2 steps from "book"
```

All `<script>`s are copied from the `<template>` and appended to the document's BODY in order.
They run only once (even if you use the component multiple times.)
-->
<template $name="text-diff" x="" y="">
  "${x}" is ${uifactory.textDiff.distance(x, y)} steps from "${y}"
  <script src="https://cdn.jsdelivr.net/npm/levenshtein@1.0.5/lib/levenshtein.js"></script>
  <script>
    /* globals Levenshtein */
    // By convention, we add any JS related to a component under uifactory.<componentName>
    uifactory.textDiff = {
      distance: (x, y) => (new Levenshtein(x, y)).distance
    }
  </script>
</template>
<text-diff x="back" y="book"></text-diff>
<script>
  tape('Add behavior with JavaScript', function (t) {
    let el = document.querySelector('text-diff')
    el.$ready.then(() => {
      t.equals(el.innerHTML.trim(), '"back" is 2 steps from "book"', 'scripts are imported and executed')
      t.end()
    })
  })
</script>


<!--
## Add events with `<script $on...>`

To add an `click` event listener to your component, write the code inside a
`<script $onclick>...</script>`, like this:

```html
<template $name="count-items" count:number="0" step:number="2">
  Click to count ${count} items in steps of ${step}.
  <script $onclick>
    this.count += step
  </script>
</template>
```

When you add the component to your page:

```html
<count-items></count-items>
```

... it renders this output:

![Click event demo](docs/img/count-items.gif)

To add a `click` event listener **to a child**, use `<script $onclick="child-selector">...</script>`:

```html
<template $name="count-button" count:number="0" step:number="2">
  <button>Click here</button>
  <span>Count: ${count}</span>
  <script $onclick="button">
    this.count += step
  </script>
</template>
```

Now, `<count-button></count-button>` renders:

![Click event on child demo](docs/img/count-button.gif)

Listeners can use these variables:

- `e` is the [event object](https://developer.mozilla.org/en-US/docs/Web/API/Event)
- `this` is the [component instance](#access-component-as-this-inside-templates)
- [Any property](#access-properties-as-variables-inside-templates), e.g. `count`, `step`

To call the listener only once, add the `$once` attribute to `<script>`:

```html
<template $name="count-once" count:number="0" step:number="2">
  <button>Click here once</button>
  <span>Count: ${count}</span>
  <script $onclick="button" $once>
    this.count += step
  </script>
</template>
```

Now, `<count-once></count-once>` renders:

![$once demo](docs/img/count-once.gif)
-->
<template $name="count-items" count:number="0" step:number="2">
  Click to count ${count} items in steps of ${step}.
  <script $onclick>
    /* globals e, step */
    console.log(e.type.toLowerCase())
    this.count += step
  </script>
</template>
<count-items></count-items>
<script>
  tape('Add events with `<script $onclick>`', function (t) {
    let el = document.querySelector('count-items')
    t.equals(el.innerHTML.trim(), 'Click to count 0 items in steps of 2.', 'count-items base')
    el.click()
    t.equals(el.innerHTML.trim(), 'Click to count 2 items in steps of 2.', 'count-items click 1')
    el.click()
    t.equals(el.innerHTML.trim(), 'Click to count 4 items in steps of 2.', 'count-items click 2')
    t.end()
  })
</script>

<template $name="count-items2" count:number="0" step:number="2">
  Click to count ${count} items in steps of ${step}.
  <script onclick>
    /* globals e, step */
    console.log(e.type.toLowerCase())
    this.count += step
  </script>
</template>
<count-items2></count-items2>
<script>
  tape('Add events with `<script onclick> -- without $ works too`', function (t) {
    let el = document.querySelector('count-items2')
    t.equals(el.innerHTML.trim(), 'Click to count 0 items in steps of 2.', 'count-items2 base')
    el.click()
    t.equals(el.innerHTML.trim(), 'Click to count 2 items in steps of 2.', 'count-items2 click 1')
    el.click()
    t.equals(el.innerHTML.trim(), 'Click to count 4 items in steps of 2.', 'count-items2 click 2')
    t.end()
  })
</script>

<template $name="count-button" count:number="0" step:number="2">
  <button class="button">Click here</button>
  <span>Count: ${count}</span>
  <script $onclick=".button">
    /* globals e, step */
    console.log(e.type.toLowerCase())
    this.count += step
  </script>
</template>
<count-button></count-button>
<script>
  tape('Add events with `<script $onclick="selector">`', function (t) {
    let el = document.querySelector('count-button')
    t.equals(el.querySelector('span').innerHTML.trim(), 'Count: 0', 'count-button base')
    el.querySelector('button').click()
    t.equals(el.querySelector('span').innerHTML.trim(), 'Count: 2', 'count-button click 1')
    el.querySelector('button').click()
    t.equals(el.querySelector('span').innerHTML.trim(), 'Count: 4', 'count-button click 2')
    t.end()
  })
</script>

<template $name="count-once" count:number="0" step:number="2">
  <button>Click here once</button>
  <span>Count: ${count}</span>
  <script $onclick="button" $once>
    this.count += step
  </script>
</template>
<count-once></count-once>
<script>
  tape('Add single listener with `<script $onclick="selector" $once>`', function (t) {
    let el = document.querySelector('count-once')
    t.equals(el.querySelector('span').innerHTML.trim(), 'Count: 0', 'count-once base')
    el.querySelector('button').click()
    t.equals(el.querySelector('span').innerHTML.trim(), 'Count: 2', 'count-once click 1')
    el.querySelector('button').click()
    t.equals(el.querySelector('span').innerHTML.trim(), 'Count: 2', 'count-once click 2')
    t.end()
  })
</script>

<!--
## Lifecycle events are supported

Components fire these events at different stages of their lifecycle:

- `preconnect`: before the instance is created and properties are defined
- `connect`: after the instance is created and properties are defined
- `prerender`: before the instance is rendered
- `render`: after the instance is rendered
- `disconnect`: after the element is disconnected from the DOM

Add `<script $onpreconnect>...</script>`, `<script $onrender>...</script>`, etc to create listeners.
For example:

```html
<template $name="repeat-events" icon="â˜…" value:number="1">
  <script $onrender>
    this.innerHTML = icon.repeat(value)
  </script>
</template>
```

Now, `<repeat-events icon="â˜…" value="8"><repeat-events>` renders this output:

![8 stars](docs/img/repeat-8-star.png)

NOTE:

- `<script $onrender $once>` creates a listener that runs only once
- `<script $onrender $onclick=".reload">` runs the listener both on render **AND** click of `class="reload"`
- Multiple `<script $onrender>...</script>` creates multiple listeners
- `this.addEventListener('render', ...)` is exactly the same as `<script $onrender>`
-->

<template $name="repeat-events" icon="â˜…" value:number="1">
  Hello
  <script src="externalscript.js"></script>
  <script onpreconnect>
    this.preconnect = {
      value: this.$data.value,
      count: this.count,
      content: this.innerHTML.trim()
    }
  </script>
  <script onconnect>
    this.connect = {
      value: this.$data.value,
      count: this.count,
      content: this.innerHTML.trim()
    }
  </script>
  <script onprerender>
    this.prerender = {
      value: this.$data.value,
      count: this.count,
      content: this.innerHTML.trim()
    }
  </script>
  <script onrender>
    /* globals icon, value */
    this.render = {
      value: this.$data.value,
      count: this.count,
      content: this.innerHTML.trim()
    }
    // Listeners can use this (the component) and properties like in templates
    this.innerHTML = icon.repeat(value)
  </script>
  <script onpreconnect onconnect onprerender onrender>
    this.count = (this.count || 0) + 1
  </script>
</template>
<repeat-events icon="â˜…" value="8"></repeat-events>

<script>
  tape('Use lifecycle events to render components using JavaScript', function (t) {
    let el = document.querySelector('repeat-events')
    t.deepEquals(el.preconnect, {value: undefined, count: undefined, content: ''}, 'script preconnect works')
    t.deepEquals(el.connect, {value: 8, count: 1, content: ''}, 'script connect works')
    t.deepEquals(el.prerender, {value: 8, count: 2, content: ''}, 'script prerender works')
    t.deepEquals(el.render, {value: 8, count: 3, content: 'Hello'}, 'script render works')
    t.end()
  })
  tape('Every render triggers a `render` event', function (t) {
    t.plan(3)
    let el = document.querySelector('repeat-events')
    el.addEventListener('render', e => t.equals(e.target.value, 3), { once: true })
    el.value = 3
    el.addEventListener('render', e => t.equals(e.target.value, 4), { once: true })
    el.value = 4
    el.addEventListener('render', e => t.equals(e.target.value, 5), { once: true })
    el.value = 5
  })
</script>


<!--
## Load components from HTML files

You can save components in a HTML file.
For example, this `tag.html` defines 2 components: `<tag-a>` and `<tag-b>`.

```html
<template $name="tag-a">This is tag-a</template>
<template $name="tag-b">This is tag-b</template>
```

To use `<tag-a>` and `<tag-b>` in your HTML file, import it with `import=`:

```html
<script src="//cdn.jsdelivr.net/npm/uifactory" import="tag.html"></script>
```
Load multiple files separated by comma and/or spaces. Relative and absolute URLs both work.

```html
<script src="//cdn.jsdelivr.net/npm/uifactory" import="
  tag.html, tag2.html, ../test/tag3.html
  https://cdn.jsdelivr.net/npm/uifactory/test/tag4.html
"></script>
```

To import [pre-built components](#use-pre-built-components), use `import="@component-name"`:

```html
<script src="//cdn.jsdelivr.net/npm/uifactory" import="@svg-chart @md-text"></script>
```

Or, if you already loaded UIFactory, use:

```html
<script>
uifactory.register('tag5.html')
</script>
```

Note:

- This uses [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch).
The fetched files must be in the same domain or
[CORS-enabled](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS).
-->
<tag-a></tag-a><tag-b></tag-b>
<script src="../src/uifactory.js" import="tag.html"></script>

<tag2-a></tag2-a>
<tag2-b></tag2-b>
<script src="../src/uifactory.js" import="tag.html, tag2.html"></script>

<tag3-a></tag3-a>
<tag3-b></tag3-b>
<tag4-a></tag4-a>
<tag4-b></tag4-b>
<script src="../src/uifactory.js" import="
  ../test/tag3.html
  https://cdn.jsdelivr.net/npm/uifactory/test/tag4.html
"></script>

<tag5-a></tag5-a>
<tag5-b></tag5-b>
<script>
uifactory.register('tag5.html')
</script>

<script src="../src/uifactory.js" import="@svg-chart @md-text"></script>
<md-text>**Strong text** and *italics*</md-text>

<script>
  tape('Import components from `import="file.html"`', function (t) {
    let tags = ['tag-a', 'tag-b', 'tag2-a', 'tag2-b', 'tag3-a', 'tag3-b', 'tag4-a', 'tag4-b', 'tag5-a', 'tag5-b']
    t.plan(tags.length)
    tags.forEach(tag => {
      document.querySelector(tag).$ready.then(function () {
        t.equals(document.querySelector(tag).innerHTML.trim(), `This is ${tag}`, `${tag} is imported`)
      })
    })
  })
  tape('Import standard components with `import="@component-name"`', function (t) {
    let el = document.querySelector('md-text')
    t.equals(el.innerHTML.trim(), `<p><strong>Strong text</strong> and <em>italics</em></p>`, `md-text imported`)
    t.end()
  })
</script>


<!-- Advanced options -->
<!-- ----------------------------------------------------------------- -->

<!--
## Register component with options

To register a component with full control over the options, use:

```html
<repeat-options value="8"></repeat-options>
<script>
// Add this AFTER the component is defined, not before. Else <slot> contents won't be defined
// See https://github.com/WICG/webcomponents/issues/551
uifactory.register({
  name: 'repeat-options',
  template: '<% for (var j=0; j<+value; j++) { %><slot></slot><% } %>',
  properties: {
    value: { value: "30", type: "number" }
  }
})
</script>
```

The object has these keys:

- `name`: component name, e.g. `"g-repeat"`
- `template`: component contents as a [template](#lodash-templates-are-supported)
- `properties`: OPTIONAL: mapping of [properties](#define-property-types-as-json) as `name: {value, type}` property definitions
- `window`: OPTIONAL: the [Window](https://developer.mozilla.org/en-US/docs/Web/API/Window) on which to register the component. Used to define components on other windows or IFrames
- `compile`: OPTIONAL: the [template compiler](#use-any-compiler) function to use
-->
<repeat-options value="8">â˜…</repeat-options>
<script>
uifactory.register({
  name: 'repeat-options',
  template: '<% for (var j=0; j<+value; j++) { %><slot></slot><% } %>',
  properties: {
    value: { value: "30", type: "number" }
  }
})
</script>
<script>
  tape('Register component with options', function (t) {
    let el = document.querySelector('repeat-options')
    // NOTE: This test NEED NOT WORK if repeat-optons is defined BEFORE it's used
    t.equals(el.innerHTML.trim(), 'â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…', 'uifactory.register() works')
    t.end()
  })
</script>

<!--
## `this.$data[property]` stores all properties

All properties are stored in `this.$data` as an object. You can read and write these values.
For example, this `<print-default>` component changes the default attribute before rendering:

```html
<template $name="print-default" default="old">
  <script onprerender>
    console.log(this.$data)     // Prints { "default": "old" }
    this.$data.default = 'new'  // Updates default value
  </script>
  <%= this.$data.default %>     // renders "new"
</template>
```

Normally, properties are ALSO accessible as `this.<attributeName>`.
But if you define a `<template query-selector="xx">`, will `this.querySelector` be "xx" or the
[this.querySelector()](https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelector) function?

ANS: `this.querySelector` is the function. `this.$data.querySelector` holds "xx".

This is be useful if you don't know whether a property is defined or not.
For example, when you add this to your page:

```html
<template $name="obj-values" x:number="0" y:number="0">
  Properties:
    <% for (let key in this.$data) { %>
      <%= key %>=<%= this.$data[key] %>
    <% } %>
  z=<%= 'z' in this.$data ? 'defined' : 'undefined' %>
</template>
<obj-values x="10" y="20"></obj-values>
```

... it renders this output:

`Properties: x=10 y=20 z=undefined`
-->
<template $name="print-default" default="old">
  <script onprerender>
    console.log(this.$data)     // Prints { "default": "old" }
    this.$data.default = 'new'  // Updates default value
  </script>
  <%= this.$data.default %>
</template>
<print-default></print-default>
<template $name="obj-values" x:number="0" y:number="0">
  Properties:
    <% for (let key in this.$data) { %>
      <%= key %>=<%= this.$data[key] %>
    <% } %>
  z=<%= 'z' in this.$data ? 'defined' : 'undefined' %>
</template>
<obj-values x="10" y="20"></obj-values>
<script>
  tape('`this.$data[property]` stores all properties', function (t) {
    let el = document.querySelector('print-default')
    t.equals(el.innerHTML.trim(), 'new', 'this.$data can be updated')
    el = document.querySelector('obj-values')
    t.equals(el.innerHTML.trim().split(/\s+/).join(' '), 'Properties: x=10 y=20 z=undefined', 'this.$data works')
    t.end()
  })
</script>


<!--
## `this.$id` hold a unique ID for each component

If you generate an `id=` attribute in your component, you need a unique identifier for each
component. `this.$id` has a string that's unique for each component instance.

For example, this creates a label-input combination with a unique ID for each input:

```html
<template $name="label-input" type="text" label="">
  <div style="display: flex; gap: 10px">
    <label for="${this.$id}-input">${label} <small>ID: ${this.$id}-input</small></label>
    <input id="${this.$id}-input" type="${type}">
  </div>
</template>
```

Now, if you repeatedly use this component in a page:

```html
<label-input label="X"></label-input>
<label-input label="Y"></label-input>
```

... it creates elements with different IDs:

![this.$id generates unique IDs](docs/img/label-input.png)
-->
<template $name="label-input" type="text" label="">
  <div style="display: flex; gap: 10px">
    <label for="${this.$id}-input">${label} <small>ID: ${this.$id}-input</small></label>
    <input id="${this.$id}-input" type="${type}">
  </div>
</template>
<label-input label="X"></label-input>
<label-input label="Y"></label-input>
<script>
  tape('`this.$data[property]` stores all properties', function (t) {
    for (let el of document.querySelectorAll('label-input')) {
      t.ok(el.$id.match(/ui\d+/), 'this.$id exists')
      t.equals(el.querySelector('small').innerHTML, `ID: ${el.$id}-input`, 'this.$id works in template')
      t.equals(document.querySelectorAll(`#${el.$id}-input`).length, 1, 'Creates unique IDs')
    }
    t.end()
  })
</script>

<!--
## Insert components dynamically

You can dynamically insert components into the page. For example:

```html
<div id="parent1"></div>
<template $name="navigator-property" value="onLine">${value} = ${navigator[value]}</template>
<script>
  document.querySelector('#parent1').innerHTML = '<navigator-property><navigator-property>'
</script>
```

... adds a `<navigator-property>` dynamically into the `<div id="parent1">`, and renders this output:

```html
onLine = true
```

This code does the same thing:

```html
<div id="parent2"></div>
<script>
  let el = document.createElement('navigator-property')
  el.setAttribute('value', 'onLine')  // optional
  document.querySelector('#parent2').appendChild(el)
</script>
```
-->

<div id="parent1"></div>
<template $name="navigator-property" value="onLine">${value} = ${navigator[value]}</template>
<script>
  document.querySelector('#parent1').innerHTML = '<navigator-property><navigator-property>'
</script>
<div id="parent2"></div>
<script>
    let el = document.createElement('navigator-property')
    el.setAttribute('value', 'onLine')  // optional
    document.querySelector('#parent2').appendChild(el)
</script>
<script>
  tape('Create components dynamically', async function (t) {
    let el1 = await document.querySelector('#parent1 navigator-property').$ready
    let el2 = await document.querySelector('#parent2 navigator-property').$ready
    t.equals(el1.innerHTML.trim(), 'onLine = true', 'create via .innerHTML')
    t.equals(el2.innerHTML.trim(), 'onLine = true', 'create via .createElement')
  })
</script>


<!--
## Add properties to an instance using types

You can [defining properties on templates](#define-properties-using-template-attr). But you can
add properties on an instance too.

For example, if you have a `<base-component>` with a `base` or `root` attributes like this:

```html
<template $name="base-component" base:number="10" root="">
  Instance properties:
  <% for (let key in this.$data) { %>
    <%= key %>=<%= this.$data[key] %>
  <% } %>
</template>
```

... you can add a custom property when creating the element, by adding a type (e.g. `:number`) like this:

```html
<base-component child:number="20"></base-component>
```

This will render:

```text
Instance properties: base=10 root= child=20
```

The `child` JavaScript variable is now available (as a number).

You can update instance property `.child=...` or the attribute `child:number=`

```html
<script>
  document.querySelector('base-component').child = 30   // Redraw with child=30
  document.querySelector('base-component').setAttribute('child:number', '40')
</script>
```

The instance types **override** the template. For example, here, `base` and `root` are defined as
`:js`, which overrides the template's `base:number`:

```html
<base-component child:number="20" base:js="1 + 2" root:js="2 + 3"></base-component>
```

This will render:

```text
Instance properties: base=3 src=5 child=20
```
-->
<template $name="base-component" base:number="10" root:url="">
  Instance properties:
  <% for (let key in this.$data) { %>
    <%= key %>=<%= this.$data[key] %>
  <% } %>
</template>
<base-component child:number="20">Hello world</base-component>
<base-component child:number="20" base:js="1 + 2" root:js="2 + 3"></base-component>
<script>
  tape('Add properties to an instance using types', function (t) {
    let els = document.querySelectorAll('base-component')
    t.equals(els[0].innerHTML.trim().split(/\s+/).join(' '),
      `Instance properties: base=10 root= child=20`,
      `Instance property added`)
    t.equals(els[1].innerHTML.trim().split(/\s+/).join(' '),
      `Instance properties: base=3 root=5 child=20`,
      `Instance property overrides`)

    function check(t, val) {
      if (els[0].$data.child != val)
        return setTimeout(check, 100, t, val)
      t.equals(els[0].innerHTML.trim().split(/\s+/).join(' '),
        `Instance properties: base=10 root= child=${val}`)
      t.end()
    }
    t.test('Instance property= re-renders', t => {
      els[0].child = 30
      els[0].update()
      check(t, 30)
    })
    t.test('Instance .update({property}) re-renders', t => {
      els[0].update({ child: 35 })
      check(t, 35)
    })
    t.test('Instance attribute= re-renders', t => {
      els[0].setAttribute('child:number', '40')
      check(t, 40)
    })
  })
</script>


<!--
## Add custom types

We define property types on attributes like this: `attr:type="value"`. The default types are
`string` (default), `number`, `boolean`, `array`, `object` or `js`.

You can add a new custom type by extending `uifactory.types`. For example:

```js
uifactory.types.newtype = {
  parse: string => ...,         // Function to convert string to value
  stringify: value => ...       // Function to convert value to string
}
```

Let's add type called `:range`, which creates an array of values:

```js
uifactory.types.range = {
  // Parse a string like seq:range="0,10,2" into [0, 2, 4, 6, 8]
  parse: string => {
    // Pick start, step, end as the first 3 numbers in the string
    let [start, end, step] = string.split(/\D+/)
    // Convert it into an array
    let result = []
    for (let val = (+start || 0); val < (+end || 1); val += (+step || 1))
      result.push(val)
    return result
  },
  // Stringify an array like [0, 2, 4, 6, 8] into "0,10,2"
  stringify: value => {
    let start = value[0]                      // First value, e.g. 0
    let step = value[1] - value[0]            // 2nd - 1st value, e.g. 2
    let end = value[value.length - 1] + step  // Last value + step, e.g. 8 + 2 = 10
    return `${start},${end},${step}`
  }
}
```

When you add a component using this custom type to your page:

```html
<template $name="custom-range" series:range="">
  Values are <%= JSON.stringify(series) %>
</template>
<custom-range series="0,10,2"></custom-range>
```

... it renders this output:

`Values are [0,2,4,6,8]`
-->
<script>
uifactory.types.range = {
  // Parse a string like seq:range="0,10,2" into [0, 2, 4, 6, 8]
  parse: string => {
    // Pick start, step, end as the first 3 numbers in the string
    let [start, end, step] = string.split(/\D+/)
    // Convert it into an array
    let result = []
    for (let val = (+start || 0); val < (+end || 1); val += (+step || 1))
      result.push(val)
    return result
  },
  // Stringify an array like [0, 2, 4, 6, 8] into "0,10,2"
  stringify: value => {
    let start = value[0]                      // First value, e.g. 0
    let step = value[1] - value[0]            // 2nd - 1st value, e.g. 2
    let end = value[value.length - 1] + step  // Last value + step, e.g. 8 + 2 = 10
    return `${start},${end},${step}`
  }
}
</script>
<template $name="custom-range" series:range="">
  Values are <%= JSON.stringify(series) %>
</template>
<custom-range series="0,10,2"></custom-range>
<script>
  tape('Add custom types', function (t) {
    let el = document.querySelector('custom-range')
    t.equals(el.innerHTML.trim(), 'Values are [0,2,4,6,8]')
    t.end()
  })
</script>


<!--
## Custom types need a parse and stringify function

Each [custom type](#add-custom-types) you add to `uifactory.types` needs a `parse` and `stringify`
functions with the following signature:

- `parse(string, name, data)`: Converts the attribute `name:type="string"` into the property `el.$data.name`
  - `string`: string value of the attribute
  - `name`: name of the attribute. (Property names are in camelCase. This is in kebab-case)
  - `data`: all properties of the component, computed so far
- `stringify(value, name, data)`: Converts the property `el.$data.name == value` into a attribute value string
  - `value`: JavaScript object holding the property value
  - `name`: name of the attribute. (Property names are in camelCase. This is in kebab-case)
  - `data`: all properties of the component, computed so far

It can be quite useful to have all properties available as `data`. This lets you parse attributes
based on previous attributes.

For example, let's create a `:formula` type that executes JavaScript. For example:

```js
uifactory.types.formula = {
  // Compile string into a JavaScript function, call it with data, return the result
  parse: (string, name, data) => {
    let fn = new Function('data', `with (data) { return (${string}) }`)
    return fn(data)
  },
  // Just convert the value into a JSON string
  stringify: value => JSON.stringify(value)
}
```

When you add a component using this custom type to your page:

```html
<template $name="custom-formula" x:number="0">
  x=<%= x %>, y=<%= y %>, z=<%= z %>
</template>
<custom-formula x="10" y:formula="x * x" z:formula="2 * y + x"></custom-formula>
```

... it renders this output:

`x=10, y=100, z=210`

The `:formula` type evaluates values in the context of previous values.
-->
<script>
uifactory.types.formula = {
  // Compile string into a JavaScript function, call it with data, return the result
  parse: (string, name, data) => {
    let fn = new Function('data', `with (data) { return (${string}) }`)
    return fn(data)
  },
  // Just convert the value into a JSON string
  stringify: value => JSON.stringify(value)
}
</script>
<template $name="custom-formula" x:number="0">
  x=<%= x %>, y=<%= y %>, z=<%= z %>
</template>
<custom-formula x="10" y:formula="x * x" z:formula="2 * y + x"></custom-formula>

<script>
  tape('Custom types need a parse and stringify function', function (t) {
    let el = document.querySelector('custom-formula')
    t.equals(el.innerHTML.trim(), 'x=10, y=100, z=210', ':formula works')
    t.end()
  })
</script>

<!--
## Check if ready with `.$ready`

You can check if a component is ready (i.e. rendered for the first time), using the
`.$ready` Promise. For example, this component uses an external script. It may time to
get read.

```html
<template $name="text-diff2" x="" y="">
  ${x} is <strong>${uifactory.textDiff2.distance(x, y)} steps</strong> from ${y}
  <script src="https://cdn.jsdelivr.net/npm/levenshtein@1.0.5/lib/levenshtein.js"></script>
  <script>
    // By convention, we add any JS related to a component under uifactory.<componentName>
    uifactory.textDiff2 = {
      distance: (x, y) => (new Levenshtein(x, y)).distance
    }
  </script>
</template>

<text-diff2 x="back" y="book"></text-diff>
```

When check if it has been ready, use:

```js
  let el = await document.querySelector('text-diff2').$ready
  // The <strong> child will be present only after the component is ready.
  el.querySelector('strong').style.color = 'red'
```

It turns the `<strong>` element red when it's ready:

![When ready, element is rendered](docs/img/text-diff2.png)
-->
<template $name="text-diff2" x="" y="">
  ${x} is <strong>${uifactory.textDiff2.distance(x, y)} steps</strong> from ${y}
  <script src="https://cdn.jsdelivr.net/npm/levenshtein@1.0.5/lib/levenshtein.js"></script>
  <script>
    /* globals Levenshtein */
    // By convention, we add any JS related to a component under uifactory.<componentName>
    uifactory.textDiff2 = {
      distance: (x, y) => (new Levenshtein(x, y)).distance
    }
  </script>
</template>

<text-diff2 x="back" y="book"></text-diff2>


<script>
  tape('Check if ready with `.$ready`', async function (t) {
    let el = await document.querySelector('text-diff2').$ready
    // The <strong> child will be present only after the component is ready.
    el.querySelector('strong').style.color = 'red'
    t.equals(el.querySelector('strong').style.color, 'red', '.$ready works')
  })
</script>


<!--
## Get registered components from `uifactory.components`

If you register a `<ui-config>` component, `uifactory.components['ui-config']` has the component's
configuration, i.e. its name, properties, template, and any other options used to register the
component.

For example, this component renders its own configuration.

```html
<template $name="ui-config" str="x" arr:array="[3,4]" expr:js="3 + 2">
  <%= JSON.stringify(uifactory.components['ui-config']) %>
</template>
```

When you add the component to your page:

```html
<ui-config></ui-config>
```

... it renders this output:

```json
{
  "name": "ui-config",
  "properties": {
    "str": {
      "type": "string",
      "value": "x"
    },
    "arr": {
      "type": "array",
      "value": "[3,4]"
    },
    "expr": {
      "type": "js",
      "value": "3 + 2"
    }
  },
  "template": "\n <%= JSON.stringify(uifactory.components['ui-config']) %>\n"
}
```
-->

<template $name="ui-config" str="x" arr:array="[3,4]" expr:js="3 + 2">
  <%= JSON.stringify(uifactory.components['ui-config']) %>
</template>
<ui-config></ui-config>

<script>
  tape('Get registered components from `uifactory.components`', function (t) {
    let el = document.querySelector('ui-config')
    t.equals(uifactory.unescape(el.innerHTML.trim()).replace(/\s+/g, ''), JSON.stringify(
      {
        "name": "ui-config",
        "properties": {
          "str": {
            "type": "string",
            "value": "x"
          },
          "arr": {
            "type": "array",
            "value": "[3,4]"
          },
          "expr": {
            "type": "js",
            "value": "3 + 2"
          }
        },
        "template": "\n <%= JSON.stringify(uifactory.components['ui-config']) %>\n",
      }
    ).replace(/\s+/g, ''))
    t.end()
  })
</script>


<!--
## Use any renderer

Gramex renders the generated HTML into a node by setting `node.innerHTML = html`.
This removes all existing DOM elements and creates new ones.

This is not good if you have event handlers, or want animations. For example, if you want to
rescale a chart's axis smoothly without re-drawing.

You can instead specify a custom `$render:js="myfunction"` where `myfunction(node, html)` updates
the `node` in any way.

For example, here's an SVG component that smoothly animates

```html
<template $name="move-circle" x="0" $render:js="uifactory.moveCircle">
  <svg width="400" height="100" fill="#eee">
    <circle cx="<%= x %>" cy="50" r="30" fill="red"></circle>
  </svg>
  <style>
    move-circle circle {
      transition: all 0.5s ease;
    }
  </style>
  <script>
    // Define a moveCircle function that accepts node as the first parameter.
    // It's called whenever the component is created or updated
    uifactory.moveCircle = function (node, html) {
      let circle = node.querySelector('circle')
      // The first time, it has no child circle. So set the HTML
      if (!circle)
        node.innerHTML = html
      // After that, don't redraw. Update the circle
      else
        node.querySelector('circle').setAttribute('cx', node.$data.x)
    }
  </script>
</template>
<move-circle x="100"></move-circle>
```

Now, suppose you change the circle's color programmatically and then change the `x=""` attribute:

```html
<script>
  document.querySelector('move-circle circle').setAttribute('fill', 'blue')
  document.querySelector('move-circle circle').setAttribute('x', '200')
</script>
```

... the circle is not redrawn. It stays blue. It smoothly moves to `x="200"`.
-->
<template $name="move-circle" x="0" $render:js="uifactory.moveCircle">
  <svg width="400" height="100" fill="#eee">
    <circle cx="<%= x %>" cy="50" r="30" fill="red"></circle>
  </svg>
  <style>
    move-circle circle {
      transition: all 0.5s ease;
    }
  </style>
  <script>
    // Define a moveCircle function that accepts node as the first parameter.
    // It's called whenever the component is created or updated
    uifactory.moveCircle = function (node, html) {
      let circle = node.querySelector('circle')
      // The first time, it has no child circle. So set the HTML
      if (!circle)
        node.innerHTML = html
      // After that, don't redraw. Update the circle
      else
        node.querySelector('circle').setAttribute('cx', node.$data.x)
    }
  </script>
</template>
<move-circle x="100"></move-circle>
<script>
  tape('Use any renderer', function (t) {
    let el = document.querySelector('move-circle circle')
    t.equals(el.getAttribute('fill'), 'red')
    el.setAttribute('fill', 'blue')
    el.setAttribute('x', '200')
    t.equals(el.getAttribute('fill'), 'blue')
    t.equals(el.getAttribute('x'), '200')
    t.end()
  })
</script>


<!--
## `<script $inline>` runs scripts while rendering

To add logic to your component, add any JavaScript inside `<script $inline>`. This runs when the component is rendered.

```html
<template $name="repeat-script" icon="X" value="30">
  <script $inline>
    let count = +value
    let result = isNaN(count) ? 'error' : icon.repeat(count)
  </script>
  ${result}
</template>
```

When you add the component to your page:

```html
<repeat-script icon="â˜…" value="8"></repeat-html>
<repeat-script icon="â˜…" value="a"></repeat-html>
```

... it renders this output:

â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜… error
-->
<template $name="repeat-script" icon="X" value="30">
  <script $inline>
    /* exported result */
    let count = +value
    let result = isNaN(count) ? 'error' : icon.repeat(count)
  </script>
  ${result}
</template>
<repeat-script icon="â˜…" value="8"></repeat-script>
<repeat-script icon="â˜…" value="a"></repeat-script>
<script>
  tape('`<script $inline>` runs scripts while rendering', function(t) {
    let els = document.querySelectorAll('repeat-script')
    t.equals(els[0].innerHTML.trim(), 'â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…', 'script $inline works')
    t.equals(els[1].innerHTML.trim(), 'error', 'script $inline works')
    t.end()
  })
</script>

<template $name="inline-script" z:number="0">
  <script $inline $onrender>
    /* exported x, y */
    let x = 30
    let y = 20
    window.testInlineScript = 1 + (window.testInlineScript || 0)
  </script>
  ${x + y + z}
</template>
<inline-script></inline-script>
<script>
  tape('$inline works with $render', function (t) {
    let el = document.querySelector('inline-script')
    t.equals(el.innerHTML.trim(), '50', '$inline executed')
    t.equals(window.testInlineScript, 2, '$render executed')
    el.setAttribute('z', '10')
    t.equals(el.innerHTML.trim(), '60', '$inline executed')
    t.equals(window.testInlineScript, 4, '$render executed')
    t.end()
  })
</script>


<script src="works-even-with-missing-script">
  // If there's a missing script, ensure that tests are not disrupted because of delays in load
</script>

<script>
  // Run tests after all scripts are loaded
  __tests.forEach(([msg, fn]) => __tape(msg, fn))
  // server.js needs a renderComplete to know that the tests are done
  __tape.onFinish(function () {
    window.renderComplete = true
  })
</script>
</body>
</html>
